{"version":3,"sources":["__prelude__","/Users/gongxi33/dev/outsource/rail/rail-app/rail-all/node_modules/metro-runtime/src/polyfills/require.js","/Users/gongxi33/dev/outsource/rail/rail-app/rail-all/node_modules/@react-native/polyfills/console.js","/Users/gongxi33/dev/outsource/rail/rail-app/rail-all/node_modules/@react-native/polyfills/error-guard.js","/Users/gongxi33/dev/outsource/rail/rail-app/rail-all/node_modules/@react-native/polyfills/Object.es8.js","/Users/gongxi33/dev/outsource/rail/rail-app/rail-all/index.js","/Users/gongxi33/dev/outsource/rail/rail-app/rail-all/node_modules/@tarojs/rn-supporter/entry-file.js"],"sourcesContent":["var __BUNDLE_START_TIME__=this.nativePerformanceNow?nativePerformanceNow():Date.now(),__DEV__=false,process=this.process||{},__METRO_GLOBAL_PREFIX__='';process.env=process.env||{};process.env.NODE_ENV=process.env.NODE_ENV||\"production\";","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @polyfill\n *\n * @format\n */\n\"use strict\";\n/* eslint-disable no-bitwise */\n\nglobal.__r = metroRequire;\nglobal[`${__METRO_GLOBAL_PREFIX__}__d`] = define;\nglobal.__c = clear;\nglobal.__registerSegment = registerSegment;\nvar modules = clear(); // Don't use a Symbol here, it would pull in an extra polyfill with all sorts of\n// additional stuff (e.g. Array.from).\n\nconst EMPTY = {};\nconst CYCLE_DETECTED = {};\nconst { hasOwnProperty } = {};\n\nif (__DEV__) {\n  global.$RefreshReg$ = () => {};\n\n  global.$RefreshSig$ = () => (type) => type;\n}\n\nfunction clear() {\n  modules = Object.create(null); // We return modules here so that we can assign an initial value to modules\n  // when defining it. Otherwise, we would have to do \"let modules = null\",\n  // which will force us to add \"nullthrows\" everywhere.\n\n  return modules;\n}\n\nif (__DEV__) {\n  var verboseNamesToModuleIds = Object.create(null);\n  var initializingModuleIds = [];\n}\n\nfunction define(factory, moduleId, dependencyMap) {\n  if (modules[moduleId] != null) {\n    if (__DEV__) {\n      // (We take `inverseDependencies` from `arguments` to avoid an unused\n      // named parameter in `define` in production.\n      const inverseDependencies = arguments[4]; // If the module has already been defined and the define method has been\n      // called with inverseDependencies, we can hot reload it.\n\n      if (inverseDependencies) {\n        global.__accept(moduleId, factory, dependencyMap, inverseDependencies);\n      }\n    } // prevent repeated calls to `global.nativeRequire` to overwrite modules\n    // that are already loaded\n\n    return;\n  }\n\n  const mod = {\n    dependencyMap,\n    factory,\n    hasError: false,\n    importedAll: EMPTY,\n    importedDefault: EMPTY,\n    isInitialized: false,\n    publicModule: {\n      exports: {},\n    },\n  };\n  modules[moduleId] = mod;\n\n  if (__DEV__) {\n    // HMR\n    mod.hot = createHotReloadingObject(); // DEBUGGABLE MODULES NAMES\n    // we take `verboseName` from `arguments` to avoid an unused named parameter\n    // in `define` in production.\n\n    const verboseName = arguments[3];\n\n    if (verboseName) {\n      mod.verboseName = verboseName;\n      verboseNamesToModuleIds[verboseName] = moduleId;\n    }\n  }\n}\n\nfunction metroRequire(moduleId) {\n  if (__DEV__ && typeof moduleId === \"string\") {\n    const verboseName = moduleId;\n    moduleId = verboseNamesToModuleIds[verboseName];\n\n    if (moduleId == null) {\n      throw new Error(`Unknown named module: \"${verboseName}\"`);\n    } else {\n      console.warn(\n        `Requiring module \"${verboseName}\" by name is only supported for ` +\n          \"debugging purposes and will BREAK IN PRODUCTION!\"\n      );\n    }\n  } //$FlowFixMe: at this point we know that moduleId is a number\n\n  const moduleIdReallyIsNumber = moduleId;\n\n  if (__DEV__) {\n    const initializingIndex = initializingModuleIds.indexOf(\n      moduleIdReallyIsNumber\n    );\n\n    if (initializingIndex !== -1) {\n      const cycle = initializingModuleIds\n        .slice(initializingIndex)\n        .map((id) => (modules[id] ? modules[id].verboseName : \"[unknown]\"));\n\n      if (shouldPrintRequireCycle(cycle)) {\n        cycle.push(cycle[0]); // We want to print A -> B -> A:\n\n        console.warn(\n          `Require cycle: ${cycle.join(\" -> \")}\\n\\n` +\n            \"Require cycles are allowed, but can result in uninitialized values. \" +\n            \"Consider refactoring to remove the need for a cycle.\"\n        );\n      }\n    }\n  }\n\n  const module = modules[moduleIdReallyIsNumber];\n  return module && module.isInitialized\n    ? module.publicModule.exports\n    : guardedLoadModule(moduleIdReallyIsNumber, module);\n} // We print require cycles unless they match a pattern in the\n// `requireCycleIgnorePatterns` configuration.\n\nfunction shouldPrintRequireCycle(modules) {\n  const regExps =\n    global[__METRO_GLOBAL_PREFIX__ + \"__requireCycleIgnorePatterns\"];\n\n  if (!Array.isArray(regExps)) {\n    return true;\n  }\n\n  const isIgnored = (module) =>\n    module != null && regExps.some((regExp) => regExp.test(module)); // Print the cycle unless any part of it is ignored\n\n  return modules.every((module) => !isIgnored(module));\n}\n\nfunction metroImportDefault(moduleId) {\n  if (__DEV__ && typeof moduleId === \"string\") {\n    const verboseName = moduleId;\n    moduleId = verboseNamesToModuleIds[verboseName];\n  } //$FlowFixMe: at this point we know that moduleId is a number\n\n  const moduleIdReallyIsNumber = moduleId;\n\n  if (\n    modules[moduleIdReallyIsNumber] &&\n    modules[moduleIdReallyIsNumber].importedDefault !== EMPTY\n  ) {\n    return modules[moduleIdReallyIsNumber].importedDefault;\n  }\n\n  const exports = metroRequire(moduleIdReallyIsNumber);\n  const importedDefault =\n    exports && exports.__esModule ? exports.default : exports; // $FlowFixMe The metroRequire call above will throw if modules[id] is null\n\n  return (modules[moduleIdReallyIsNumber].importedDefault = importedDefault);\n}\n\nmetroRequire.importDefault = metroImportDefault;\n\nfunction metroImportAll(moduleId) {\n  if (__DEV__ && typeof moduleId === \"string\") {\n    const verboseName = moduleId;\n    moduleId = verboseNamesToModuleIds[verboseName];\n  } //$FlowFixMe: at this point we know that moduleId is a number\n\n  const moduleIdReallyIsNumber = moduleId;\n\n  if (\n    modules[moduleIdReallyIsNumber] &&\n    modules[moduleIdReallyIsNumber].importedAll !== EMPTY\n  ) {\n    return modules[moduleIdReallyIsNumber].importedAll;\n  }\n\n  const exports = metroRequire(moduleIdReallyIsNumber);\n  let importedAll;\n\n  if (exports && exports.__esModule) {\n    importedAll = exports;\n  } else {\n    importedAll = {}; // Refrain from using Object.assign, it has to work in ES3 environments.\n\n    if (exports) {\n      for (const key in exports) {\n        if (hasOwnProperty.call(exports, key)) {\n          importedAll[key] = exports[key];\n        }\n      }\n    }\n\n    importedAll.default = exports;\n  } // $FlowFixMe The metroRequire call above will throw if modules[id] is null\n\n  return (modules[moduleIdReallyIsNumber].importedAll = importedAll);\n}\n\nmetroRequire.importAll = metroImportAll; // The `require.context()` syntax is never executed in the runtime because it is converted\n// to `require()` in `metro/src/ModuleGraph/worker/collectDependencies.js` after collecting\n// dependencies. If the feature flag is not enabled then the conversion never takes place and this error is thrown (development only).\n\nmetroRequire.context = function fallbackRequireContext() {\n  if (__DEV__) {\n    throw new Error(\n      \"The experimental Metro feature `require.context` is not enabled in your project.\\nThis can be enabled by setting the `transformer.unstable_allowRequireContext` property to `true` in your Metro configuration.\"\n    );\n  }\n\n  throw new Error(\n    \"The experimental Metro feature `require.context` is not enabled in your project.\"\n  );\n};\n\nlet inGuard = false;\n\nfunction guardedLoadModule(moduleId, module) {\n  if (!inGuard && global.ErrorUtils) {\n    inGuard = true;\n    let returnValue;\n\n    try {\n      returnValue = loadModuleImplementation(moduleId, module);\n    } catch (e) {\n      // TODO: (moti) T48204692 Type this use of ErrorUtils.\n      global.ErrorUtils.reportFatalError(e);\n    }\n\n    inGuard = false;\n    return returnValue;\n  } else {\n    return loadModuleImplementation(moduleId, module);\n  }\n}\n\nconst ID_MASK_SHIFT = 16;\nconst LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;\n\nfunction unpackModuleId(moduleId) {\n  const segmentId = moduleId >>> ID_MASK_SHIFT;\n  const localId = moduleId & LOCAL_ID_MASK;\n  return {\n    segmentId,\n    localId,\n  };\n}\n\nmetroRequire.unpackModuleId = unpackModuleId;\n\nfunction packModuleId(value) {\n  return (value.segmentId << ID_MASK_SHIFT) + value.localId;\n}\n\nmetroRequire.packModuleId = packModuleId;\nconst moduleDefinersBySegmentID = [];\nconst definingSegmentByModuleID = new Map();\n\nfunction registerSegment(segmentId, moduleDefiner, moduleIds) {\n  moduleDefinersBySegmentID[segmentId] = moduleDefiner;\n\n  if (__DEV__) {\n    if (segmentId === 0 && moduleIds) {\n      throw new Error(\n        \"registerSegment: Expected moduleIds to be null for main segment\"\n      );\n    }\n\n    if (segmentId !== 0 && !moduleIds) {\n      throw new Error(\n        \"registerSegment: Expected moduleIds to be passed for segment #\" +\n          segmentId\n      );\n    }\n  }\n\n  if (moduleIds) {\n    moduleIds.forEach((moduleId) => {\n      if (!modules[moduleId] && !definingSegmentByModuleID.has(moduleId)) {\n        definingSegmentByModuleID.set(moduleId, segmentId);\n      }\n    });\n  }\n}\n\nfunction loadModuleImplementation(moduleId, module) {\n  if (!module && moduleDefinersBySegmentID.length > 0) {\n    var _definingSegmentByMod;\n\n    const segmentId =\n      (_definingSegmentByMod = definingSegmentByModuleID.get(moduleId)) !==\n        null && _definingSegmentByMod !== void 0\n        ? _definingSegmentByMod\n        : 0;\n    const definer = moduleDefinersBySegmentID[segmentId];\n\n    if (definer != null) {\n      definer(moduleId);\n      module = modules[moduleId];\n      definingSegmentByModuleID.delete(moduleId);\n    }\n  }\n\n  const nativeRequire = global.nativeRequire;\n\n  if (!module && nativeRequire) {\n    const { segmentId, localId } = unpackModuleId(moduleId);\n    nativeRequire(localId, segmentId);\n    module = modules[moduleId];\n  }\n\n  if (!module) {\n    throw unknownModuleError(moduleId);\n  }\n\n  if (module.hasError) {\n    throw moduleThrewError(moduleId, module.error);\n  }\n\n  if (__DEV__) {\n    var Systrace = requireSystrace();\n    var Refresh = requireRefresh();\n  } // We must optimistically mark module as initialized before running the\n  // factory to keep any require cycles inside the factory from causing an\n  // infinite require loop.\n\n  module.isInitialized = true;\n  const { factory, dependencyMap } = module;\n\n  if (__DEV__) {\n    initializingModuleIds.push(moduleId);\n  }\n\n  try {\n    if (__DEV__) {\n      // $FlowIgnore: we know that __DEV__ is const and `Systrace` exists\n      Systrace.beginEvent(\"JS_require_\" + (module.verboseName || moduleId));\n    }\n\n    const moduleObject = module.publicModule;\n\n    if (__DEV__) {\n      moduleObject.hot = module.hot;\n      var prevRefreshReg = global.$RefreshReg$;\n      var prevRefreshSig = global.$RefreshSig$;\n\n      if (Refresh != null) {\n        const RefreshRuntime = Refresh;\n\n        global.$RefreshReg$ = (type, id) => {\n          RefreshRuntime.register(type, moduleId + \" \" + id);\n        };\n\n        global.$RefreshSig$ =\n          RefreshRuntime.createSignatureFunctionForTransform;\n      }\n    }\n\n    moduleObject.id = moduleId; // keep args in sync with with defineModuleCode in\n    // metro/src/Resolver/index.js\n    // and metro/src/ModuleGraph/worker.js\n\n    factory(\n      global,\n      metroRequire,\n      metroImportDefault,\n      metroImportAll,\n      moduleObject,\n      moduleObject.exports,\n      dependencyMap\n    ); // avoid removing factory in DEV mode as it breaks HMR\n\n    if (!__DEV__) {\n      // $FlowFixMe: This is only sound because we never access `factory` again\n      module.factory = undefined;\n      module.dependencyMap = undefined;\n    }\n\n    if (__DEV__) {\n      // $FlowIgnore: we know that __DEV__ is const and `Systrace` exists\n      Systrace.endEvent();\n\n      if (Refresh != null) {\n        registerExportsForReactRefresh(Refresh, moduleObject.exports, moduleId);\n      }\n    }\n\n    return moduleObject.exports;\n  } catch (e) {\n    module.hasError = true;\n    module.error = e;\n    module.isInitialized = false;\n    module.publicModule.exports = undefined;\n    throw e;\n  } finally {\n    if (__DEV__) {\n      if (initializingModuleIds.pop() !== moduleId) {\n        throw new Error(\n          \"initializingModuleIds is corrupt; something is terribly wrong\"\n        );\n      }\n\n      global.$RefreshReg$ = prevRefreshReg;\n      global.$RefreshSig$ = prevRefreshSig;\n    }\n  }\n}\n\nfunction unknownModuleError(id) {\n  let message = 'Requiring unknown module \"' + id + '\".';\n\n  if (__DEV__) {\n    message +=\n      \" If you are sure the module exists, try restarting Metro. \" +\n      \"You may also want to run `yarn` or `npm install`.\";\n  }\n\n  return Error(message);\n}\n\nfunction moduleThrewError(id, error) {\n  const displayName = (__DEV__ && modules[id] && modules[id].verboseName) || id;\n  return Error(\n    'Requiring module \"' + displayName + '\", which threw an exception: ' + error\n  );\n}\n\nif (__DEV__) {\n  metroRequire.Systrace = {\n    beginEvent: () => {},\n    endEvent: () => {},\n  };\n\n  metroRequire.getModules = () => {\n    return modules;\n  }; // HOT MODULE RELOADING\n\n  var createHotReloadingObject = function () {\n    const hot = {\n      _acceptCallback: null,\n      _disposeCallback: null,\n      _didAccept: false,\n      accept: (callback) => {\n        hot._didAccept = true;\n        hot._acceptCallback = callback;\n      },\n      dispose: (callback) => {\n        hot._disposeCallback = callback;\n      },\n    };\n    return hot;\n  };\n\n  let reactRefreshTimeout = null;\n\n  const metroHotUpdateModule = function (\n    id,\n    factory,\n    dependencyMap,\n    inverseDependencies\n  ) {\n    const mod = modules[id];\n\n    if (!mod) {\n      if (factory) {\n        // New modules are going to be handled by the define() method.\n        return;\n      }\n\n      throw unknownModuleError(id);\n    }\n\n    if (!mod.hasError && !mod.isInitialized) {\n      // The module hasn't actually been executed yet,\n      // so we can always safely replace it.\n      mod.factory = factory;\n      mod.dependencyMap = dependencyMap;\n      return;\n    }\n\n    const Refresh = requireRefresh();\n    const refreshBoundaryIDs = new Set(); // In this loop, we will traverse the dependency tree upwards from the\n    // changed module. Updates \"bubble\" up to the closest accepted parent.\n    //\n    // If we reach the module root and nothing along the way accepted the update,\n    // we know hot reload is going to fail. In that case we return false.\n    //\n    // The main purpose of this loop is to figure out whether it's safe to apply\n    // a hot update. It is only safe when the update was accepted somewhere\n    // along the way upwards for each of its parent dependency module chains.\n    //\n    // We perform a topological sort because we may discover the same\n    // module more than once in the list of things to re-execute, and\n    // we want to execute modules before modules that depend on them.\n    //\n    // If we didn't have this check, we'd risk re-evaluating modules that\n    // have side effects and lead to confusing and meaningless crashes.\n\n    let didBailOut = false;\n    let updatedModuleIDs;\n\n    try {\n      updatedModuleIDs = topologicalSort(\n        [id], // Start with the changed module and go upwards\n        (pendingID) => {\n          const pendingModule = modules[pendingID];\n\n          if (pendingModule == null) {\n            // Nothing to do.\n            return [];\n          }\n\n          const pendingHot = pendingModule.hot;\n\n          if (pendingHot == null) {\n            throw new Error(\n              \"[Refresh] Expected module.hot to always exist in DEV.\"\n            );\n          } // A module can be accepted manually from within itself.\n\n          let canAccept = pendingHot._didAccept;\n\n          if (!canAccept && Refresh != null) {\n            // Or React Refresh may mark it accepted based on exports.\n            const isBoundary = isReactRefreshBoundary(\n              Refresh,\n              pendingModule.publicModule.exports\n            );\n\n            if (isBoundary) {\n              canAccept = true;\n              refreshBoundaryIDs.add(pendingID);\n            }\n          }\n\n          if (canAccept) {\n            // Don't look at parents.\n            return [];\n          } // If we bubble through the roof, there is no way to do a hot update.\n          // Bail out altogether. This is the failure case.\n\n          const parentIDs = inverseDependencies[pendingID];\n\n          if (parentIDs.length === 0) {\n            // Reload the app because the hot reload can't succeed.\n            // This should work both on web and React Native.\n            performFullRefresh(\"No root boundary\", {\n              source: mod,\n              failed: pendingModule,\n            });\n            didBailOut = true;\n            return [];\n          } // This module can't handle the update but maybe all its parents can?\n          // Put them all in the queue to run the same set of checks.\n\n          return parentIDs;\n        },\n        () => didBailOut // Should we stop?\n      ).reverse();\n    } catch (e) {\n      if (e === CYCLE_DETECTED) {\n        performFullRefresh(\"Dependency cycle\", {\n          source: mod,\n        });\n        return;\n      }\n\n      throw e;\n    }\n\n    if (didBailOut) {\n      return;\n    } // If we reached here, it is likely that hot reload will be successful.\n    // Run the actual factories.\n\n    const seenModuleIDs = new Set();\n\n    for (let i = 0; i < updatedModuleIDs.length; i++) {\n      const updatedID = updatedModuleIDs[i];\n\n      if (seenModuleIDs.has(updatedID)) {\n        continue;\n      }\n\n      seenModuleIDs.add(updatedID);\n      const updatedMod = modules[updatedID];\n\n      if (updatedMod == null) {\n        throw new Error(\"[Refresh] Expected to find the updated module.\");\n      }\n\n      const prevExports = updatedMod.publicModule.exports;\n      const didError = runUpdatedModule(\n        updatedID,\n        updatedID === id ? factory : undefined,\n        updatedID === id ? dependencyMap : undefined\n      );\n      const nextExports = updatedMod.publicModule.exports;\n\n      if (didError) {\n        // The user was shown a redbox about module initialization.\n        // There's nothing for us to do here until it's fixed.\n        return;\n      }\n\n      if (refreshBoundaryIDs.has(updatedID)) {\n        // Since we just executed the code for it, it's possible\n        // that the new exports make it ineligible for being a boundary.\n        const isNoLongerABoundary = !isReactRefreshBoundary(\n          Refresh,\n          nextExports\n        ); // It can also become ineligible if its exports are incompatible\n        // with the previous exports.\n        // For example, if you add/remove/change exports, we'll want\n        // to re-execute the importing modules, and force those components\n        // to re-render. Similarly, if you convert a class component\n        // to a function, we want to invalidate the boundary.\n\n        const didInvalidate = shouldInvalidateReactRefreshBoundary(\n          Refresh,\n          prevExports,\n          nextExports\n        );\n\n        if (isNoLongerABoundary || didInvalidate) {\n          // We'll be conservative. The only case in which we won't do a full\n          // reload is if all parent modules are also refresh boundaries.\n          // In that case we'll add them to the current queue.\n          const parentIDs = inverseDependencies[updatedID];\n\n          if (parentIDs.length === 0) {\n            // Looks like we bubbled to the root. Can't recover from that.\n            performFullRefresh(\n              isNoLongerABoundary\n                ? \"No longer a boundary\"\n                : \"Invalidated boundary\",\n              {\n                source: mod,\n                failed: updatedMod,\n              }\n            );\n            return;\n          } // Schedule all parent refresh boundaries to re-run in this loop.\n\n          for (let j = 0; j < parentIDs.length; j++) {\n            const parentID = parentIDs[j];\n            const parentMod = modules[parentID];\n\n            if (parentMod == null) {\n              throw new Error(\"[Refresh] Expected to find parent module.\");\n            }\n\n            const canAcceptParent = isReactRefreshBoundary(\n              Refresh,\n              parentMod.publicModule.exports\n            );\n\n            if (canAcceptParent) {\n              // All parents will have to re-run too.\n              refreshBoundaryIDs.add(parentID);\n              updatedModuleIDs.push(parentID);\n            } else {\n              performFullRefresh(\"Invalidated boundary\", {\n                source: mod,\n                failed: parentMod,\n              });\n              return;\n            }\n          }\n        }\n      }\n    }\n\n    if (Refresh != null) {\n      // Debounce a little in case there are multiple updates queued up.\n      // This is also useful because __accept may be called multiple times.\n      if (reactRefreshTimeout == null) {\n        reactRefreshTimeout = setTimeout(() => {\n          reactRefreshTimeout = null; // Update React components.\n\n          Refresh.performReactRefresh();\n        }, 30);\n      }\n    }\n  };\n\n  const topologicalSort = function (roots, getEdges, earlyStop) {\n    const result = [];\n    const visited = new Set();\n    const stack = new Set();\n\n    function traverseDependentNodes(node) {\n      if (stack.has(node)) {\n        throw CYCLE_DETECTED;\n      }\n\n      if (visited.has(node)) {\n        return;\n      }\n\n      visited.add(node);\n      stack.add(node);\n      const dependentNodes = getEdges(node);\n\n      if (earlyStop(node)) {\n        stack.delete(node);\n        return;\n      }\n\n      dependentNodes.forEach((dependent) => {\n        traverseDependentNodes(dependent);\n      });\n      stack.delete(node);\n      result.push(node);\n    }\n\n    roots.forEach((root) => {\n      traverseDependentNodes(root);\n    });\n    return result;\n  };\n\n  const runUpdatedModule = function (id, factory, dependencyMap) {\n    const mod = modules[id];\n\n    if (mod == null) {\n      throw new Error(\"[Refresh] Expected to find the module.\");\n    }\n\n    const { hot } = mod;\n\n    if (!hot) {\n      throw new Error(\"[Refresh] Expected module.hot to always exist in DEV.\");\n    }\n\n    if (hot._disposeCallback) {\n      try {\n        hot._disposeCallback();\n      } catch (error) {\n        console.error(\n          `Error while calling dispose handler for module ${id}: `,\n          error\n        );\n      }\n    }\n\n    if (factory) {\n      mod.factory = factory;\n    }\n\n    if (dependencyMap) {\n      mod.dependencyMap = dependencyMap;\n    }\n\n    mod.hasError = false;\n    mod.error = undefined;\n    mod.importedAll = EMPTY;\n    mod.importedDefault = EMPTY;\n    mod.isInitialized = false;\n    const prevExports = mod.publicModule.exports;\n    mod.publicModule.exports = {};\n    hot._didAccept = false;\n    hot._acceptCallback = null;\n    hot._disposeCallback = null;\n    metroRequire(id);\n\n    if (mod.hasError) {\n      // This error has already been reported via a redbox.\n      // We know it's likely a typo or some mistake that was just introduced.\n      // Our goal now is to keep the rest of the application working so that by\n      // the time user fixes the error, the app isn't completely destroyed\n      // underneath the redbox. So we'll revert the module object to the last\n      // successful export and stop propagating this update.\n      mod.hasError = false;\n      mod.isInitialized = true;\n      mod.error = null;\n      mod.publicModule.exports = prevExports; // We errored. Stop the update.\n\n      return true;\n    }\n\n    if (hot._acceptCallback) {\n      try {\n        hot._acceptCallback();\n      } catch (error) {\n        console.error(\n          `Error while calling accept handler for module ${id}: `,\n          error\n        );\n      }\n    } // No error.\n\n    return false;\n  };\n\n  const performFullRefresh = (reason, modules) => {\n    /* global window */\n    if (\n      typeof window !== \"undefined\" &&\n      window.location != null &&\n      typeof window.location.reload === \"function\"\n    ) {\n      window.location.reload();\n    } else {\n      const Refresh = requireRefresh();\n\n      if (Refresh != null) {\n        var _modules$source$verbo,\n          _modules$source,\n          _modules$failed$verbo,\n          _modules$failed;\n\n        const sourceName =\n          (_modules$source$verbo =\n            (_modules$source = modules.source) === null ||\n            _modules$source === void 0\n              ? void 0\n              : _modules$source.verboseName) !== null &&\n          _modules$source$verbo !== void 0\n            ? _modules$source$verbo\n            : \"unknown\";\n        const failedName =\n          (_modules$failed$verbo =\n            (_modules$failed = modules.failed) === null ||\n            _modules$failed === void 0\n              ? void 0\n              : _modules$failed.verboseName) !== null &&\n          _modules$failed$verbo !== void 0\n            ? _modules$failed$verbo\n            : \"unknown\";\n        Refresh.performFullRefresh(\n          `Fast Refresh - ${reason} <${sourceName}> <${failedName}>`\n        );\n      } else {\n        console.warn(\"Could not reload the application after an edit.\");\n      }\n    }\n  }; // Modules that only export components become React Refresh boundaries.\n\n  var isReactRefreshBoundary = function (Refresh, moduleExports) {\n    if (Refresh.isLikelyComponentType(moduleExports)) {\n      return true;\n    }\n\n    if (moduleExports == null || typeof moduleExports !== \"object\") {\n      // Exit if we can't iterate over exports.\n      return false;\n    }\n\n    let hasExports = false;\n    let areAllExportsComponents = true;\n\n    for (const key in moduleExports) {\n      hasExports = true;\n\n      if (key === \"__esModule\") {\n        continue;\n      }\n\n      const desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n\n      if (desc && desc.get) {\n        // Don't invoke getters as they may have side effects.\n        return false;\n      }\n\n      const exportValue = moduleExports[key];\n\n      if (!Refresh.isLikelyComponentType(exportValue)) {\n        areAllExportsComponents = false;\n      }\n    }\n\n    return hasExports && areAllExportsComponents;\n  };\n\n  var shouldInvalidateReactRefreshBoundary = (\n    Refresh,\n    prevExports,\n    nextExports\n  ) => {\n    const prevSignature = getRefreshBoundarySignature(Refresh, prevExports);\n    const nextSignature = getRefreshBoundarySignature(Refresh, nextExports);\n\n    if (prevSignature.length !== nextSignature.length) {\n      return true;\n    }\n\n    for (let i = 0; i < nextSignature.length; i++) {\n      if (prevSignature[i] !== nextSignature[i]) {\n        return true;\n      }\n    }\n\n    return false;\n  }; // When this signature changes, it's unsafe to stop at this refresh boundary.\n\n  var getRefreshBoundarySignature = (Refresh, moduleExports) => {\n    const signature = [];\n    signature.push(Refresh.getFamilyByType(moduleExports));\n\n    if (moduleExports == null || typeof moduleExports !== \"object\") {\n      // Exit if we can't iterate over exports.\n      // (This is important for legacy environments.)\n      return signature;\n    }\n\n    for (const key in moduleExports) {\n      if (key === \"__esModule\") {\n        continue;\n      }\n\n      const desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n\n      if (desc && desc.get) {\n        continue;\n      }\n\n      const exportValue = moduleExports[key];\n      signature.push(key);\n      signature.push(Refresh.getFamilyByType(exportValue));\n    }\n\n    return signature;\n  };\n\n  var registerExportsForReactRefresh = (Refresh, moduleExports, moduleID) => {\n    Refresh.register(moduleExports, moduleID + \" %exports%\");\n\n    if (moduleExports == null || typeof moduleExports !== \"object\") {\n      // Exit if we can't iterate over exports.\n      // (This is important for legacy environments.)\n      return;\n    }\n\n    for (const key in moduleExports) {\n      const desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n\n      if (desc && desc.get) {\n        // Don't invoke getters as they may have side effects.\n        continue;\n      }\n\n      const exportValue = moduleExports[key];\n      const typeID = moduleID + \" %exports% \" + key;\n      Refresh.register(exportValue, typeID);\n    }\n  };\n\n  global.__accept = metroHotUpdateModule;\n}\n\nif (__DEV__) {\n  // The metro require polyfill can not have module dependencies.\n  // The Systrace and ReactRefresh dependencies are, therefore, made publicly\n  // available. Ideally, the dependency would be inversed in a way that\n  // Systrace / ReactRefresh could integrate into Metro rather than\n  // having to make them publicly available.\n  var requireSystrace = function requireSystrace() {\n    return (\n      global[__METRO_GLOBAL_PREFIX__ + \"__SYSTRACE\"] || metroRequire.Systrace\n    );\n  };\n\n  var requireRefresh = function requireRefresh() {\n    return (\n      global[__METRO_GLOBAL_PREFIX__ + \"__ReactRefresh\"] || metroRequire.Refresh\n    );\n  };\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @polyfill\n * @nolint\n * @format\n */\n\n/* eslint-disable no-shadow, eqeqeq, curly, no-unused-vars, no-void, no-control-regex  */\n\n/**\n * This pipes all of our console logging functions to native logging so that\n * JavaScript errors in required modules show up in Xcode via NSLog.\n */\nconst inspect = (function() {\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  //\n  // https://github.com/joyent/node/blob/master/lib/util.js\n\n  function inspect(obj, opts) {\n    var ctx = {\n      seen: [],\n      formatValueCalls: 0,\n      stylize: stylizeNoColor,\n    };\n    return formatValue(ctx, obj, opts.depth);\n  }\n\n  function stylizeNoColor(str, styleType) {\n    return str;\n  }\n\n  function arrayToHash(array) {\n    var hash = {};\n\n    array.forEach(function(val, idx) {\n      hash[val] = true;\n    });\n\n    return hash;\n  }\n\n  function formatValue(ctx, value, recurseTimes) {\n    ctx.formatValueCalls++;\n    if (ctx.formatValueCalls > 200) {\n      return `[TOO BIG formatValueCalls ${ctx.formatValueCalls} exceeded limit of 200]`;\n    }\n\n    // Primitive types cannot have properties\n    var primitive = formatPrimitive(ctx, value);\n    if (primitive) {\n      return primitive;\n    }\n\n    // Look up the keys of the object.\n    var keys = Object.keys(value);\n    var visibleKeys = arrayToHash(keys);\n\n    // IE doesn't make error fields non-enumerable\n    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n    if (\n      isError(value) &&\n      (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)\n    ) {\n      return formatError(value);\n    }\n\n    // Some type of object without properties can be shortcutted.\n    if (keys.length === 0) {\n      if (isFunction(value)) {\n        var name = value.name ? ': ' + value.name : '';\n        return ctx.stylize('[Function' + name + ']', 'special');\n      }\n      if (isRegExp(value)) {\n        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n      }\n      if (isDate(value)) {\n        return ctx.stylize(Date.prototype.toString.call(value), 'date');\n      }\n      if (isError(value)) {\n        return formatError(value);\n      }\n    }\n\n    var base = '',\n      array = false,\n      braces = ['{', '}'];\n\n    // Make Array say that they are Array\n    if (isArray(value)) {\n      array = true;\n      braces = ['[', ']'];\n    }\n\n    // Make functions say that they are functions\n    if (isFunction(value)) {\n      var n = value.name ? ': ' + value.name : '';\n      base = ' [Function' + n + ']';\n    }\n\n    // Make RegExps say that they are RegExps\n    if (isRegExp(value)) {\n      base = ' ' + RegExp.prototype.toString.call(value);\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + Date.prototype.toUTCString.call(value);\n    }\n\n    // Make error with message first say the error\n    if (isError(value)) {\n      base = ' ' + formatError(value);\n    }\n\n    if (keys.length === 0 && (!array || value.length == 0)) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n      } else {\n        return ctx.stylize('[Object]', 'special');\n      }\n    }\n\n    ctx.seen.push(value);\n\n    var output;\n    if (array) {\n      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n    } else {\n      output = keys.map(function(key) {\n        return formatProperty(\n          ctx,\n          value,\n          recurseTimes,\n          visibleKeys,\n          key,\n          array,\n        );\n      });\n    }\n\n    ctx.seen.pop();\n\n    return reduceToSingleString(output, base, braces);\n  }\n\n  function formatPrimitive(ctx, value) {\n    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');\n    if (isString(value)) {\n      var simple =\n        \"'\" +\n        JSON.stringify(value)\n          .replace(/^\"|\"$/g, '')\n          .replace(/'/g, \"\\\\'\")\n          .replace(/\\\\\"/g, '\"') +\n        \"'\";\n      return ctx.stylize(simple, 'string');\n    }\n    if (isNumber(value)) return ctx.stylize('' + value, 'number');\n    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');\n    // For some reason typeof null is \"object\", so special case here.\n    if (isNull(value)) return ctx.stylize('null', 'null');\n  }\n\n  function formatError(value) {\n    return '[' + Error.prototype.toString.call(value) + ']';\n  }\n\n  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n    var output = [];\n    for (var i = 0, l = value.length; i < l; ++i) {\n      if (hasOwnProperty(value, String(i))) {\n        output.push(\n          formatProperty(\n            ctx,\n            value,\n            recurseTimes,\n            visibleKeys,\n            String(i),\n            true,\n          ),\n        );\n      } else {\n        output.push('');\n      }\n    }\n    keys.forEach(function(key) {\n      if (!key.match(/^\\d+$/)) {\n        output.push(\n          formatProperty(ctx, value, recurseTimes, visibleKeys, key, true),\n        );\n      }\n    });\n    return output;\n  }\n\n  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n    var name, str, desc;\n    desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};\n    if (desc.get) {\n      if (desc.set) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (desc.set) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n    if (!hasOwnProperty(visibleKeys, key)) {\n      name = '[' + key + ']';\n    }\n    if (!str) {\n      if (ctx.seen.indexOf(desc.value) < 0) {\n        if (isNull(recurseTimes)) {\n          str = formatValue(ctx, desc.value, null);\n        } else {\n          str = formatValue(ctx, desc.value, recurseTimes - 1);\n        }\n        if (str.indexOf('\\n') > -1) {\n          if (array) {\n            str = str\n              .split('\\n')\n              .map(function(line) {\n                return '  ' + line;\n              })\n              .join('\\n')\n              .substr(2);\n          } else {\n            str =\n              '\\n' +\n              str\n                .split('\\n')\n                .map(function(line) {\n                  return '   ' + line;\n                })\n                .join('\\n');\n          }\n        }\n      } else {\n        str = ctx.stylize('[Circular]', 'special');\n      }\n    }\n    if (isUndefined(name)) {\n      if (array && key.match(/^\\d+$/)) {\n        return str;\n      }\n      name = JSON.stringify('' + key);\n      if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n        name = name.substr(1, name.length - 2);\n        name = ctx.stylize(name, 'name');\n      } else {\n        name = name\n          .replace(/'/g, \"\\\\'\")\n          .replace(/\\\\\"/g, '\"')\n          .replace(/(^\"|\"$)/g, \"'\");\n        name = ctx.stylize(name, 'string');\n      }\n    }\n\n    return name + ': ' + str;\n  }\n\n  function reduceToSingleString(output, base, braces) {\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n    }, 0);\n\n    if (length > 60) {\n      return (\n        braces[0] +\n        (base === '' ? '' : base + '\\n ') +\n        ' ' +\n        output.join(',\\n  ') +\n        ' ' +\n        braces[1]\n      );\n    }\n\n    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n  }\n\n  // NOTE: These type checking functions intentionally don't use `instanceof`\n  // because it is fragile and can be easily faked with `Object.create()`.\n  function isArray(ar) {\n    return Array.isArray(ar);\n  }\n\n  function isBoolean(arg) {\n    return typeof arg === 'boolean';\n  }\n\n  function isNull(arg) {\n    return arg === null;\n  }\n\n  function isNullOrUndefined(arg) {\n    return arg == null;\n  }\n\n  function isNumber(arg) {\n    return typeof arg === 'number';\n  }\n\n  function isString(arg) {\n    return typeof arg === 'string';\n  }\n\n  function isSymbol(arg) {\n    return typeof arg === 'symbol';\n  }\n\n  function isUndefined(arg) {\n    return arg === void 0;\n  }\n\n  function isRegExp(re) {\n    return isObject(re) && objectToString(re) === '[object RegExp]';\n  }\n\n  function isObject(arg) {\n    return typeof arg === 'object' && arg !== null;\n  }\n\n  function isDate(d) {\n    return isObject(d) && objectToString(d) === '[object Date]';\n  }\n\n  function isError(e) {\n    return (\n      isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error)\n    );\n  }\n\n  function isFunction(arg) {\n    return typeof arg === 'function';\n  }\n\n  function objectToString(o) {\n    return Object.prototype.toString.call(o);\n  }\n\n  function hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  return inspect;\n})();\n\nconst OBJECT_COLUMN_NAME = '(index)';\nconst LOG_LEVELS = {\n  trace: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\nconst INSPECTOR_LEVELS = [];\nINSPECTOR_LEVELS[LOG_LEVELS.trace] = 'debug';\nINSPECTOR_LEVELS[LOG_LEVELS.info] = 'log';\nINSPECTOR_LEVELS[LOG_LEVELS.warn] = 'warning';\nINSPECTOR_LEVELS[LOG_LEVELS.error] = 'error';\n\n// Strip the inner function in getNativeLogFunction(), if in dev also\n// strip method printing to originalConsole.\nconst INSPECTOR_FRAMES_TO_SKIP = __DEV__ ? 2 : 1;\n\nfunction getNativeLogFunction(level) {\n  return function() {\n    let str;\n    if (arguments.length === 1 && typeof arguments[0] === 'string') {\n      str = arguments[0];\n    } else {\n      str = Array.prototype.map\n        .call(arguments, function(arg) {\n          return inspect(arg, {depth: 10});\n        })\n        .join(', ');\n    }\n\n    // TRICKY\n    // If more than one argument is provided, the code above collapses them all\n    // into a single formatted string. This transform wraps string arguments in\n    // single quotes (e.g. \"foo\" -> \"'foo'\") which then breaks the \"Warning:\"\n    // check below. So it's important that we look at the first argument, rather\n    // than the formatted argument string.\n    const firstArg = arguments[0];\n\n    let logLevel = level;\n    if (\n      typeof firstArg === 'string' &&\n      firstArg.slice(0, 9) === 'Warning: ' &&\n      logLevel >= LOG_LEVELS.error\n    ) {\n      // React warnings use console.error so that a stack trace is shown,\n      // but we don't (currently) want these to show a redbox\n      // (Note: Logic duplicated in ExceptionsManager.js.)\n      logLevel = LOG_LEVELS.warn;\n    }\n    if (global.__inspectorLog) {\n      global.__inspectorLog(\n        INSPECTOR_LEVELS[logLevel],\n        str,\n        [].slice.call(arguments),\n        INSPECTOR_FRAMES_TO_SKIP,\n      );\n    }\n    if (groupStack.length) {\n      str = groupFormat('', str);\n    }\n    global.nativeLoggingHook(str, logLevel);\n  };\n}\n\nfunction repeat(element, n) {\n  return Array.apply(null, Array(n)).map(function() {\n    return element;\n  });\n}\n\nfunction consoleTablePolyfill(rows) {\n  // convert object -> array\n  if (!Array.isArray(rows)) {\n    var data = rows;\n    rows = [];\n    for (var key in data) {\n      if (data.hasOwnProperty(key)) {\n        var row = data[key];\n        row[OBJECT_COLUMN_NAME] = key;\n        rows.push(row);\n      }\n    }\n  }\n  if (rows.length === 0) {\n    global.nativeLoggingHook('', LOG_LEVELS.info);\n    return;\n  }\n\n  var columns = Object.keys(rows[0]).sort();\n  var stringRows = [];\n  var columnWidths = [];\n\n  // Convert each cell to a string. Also\n  // figure out max cell width for each column\n  columns.forEach(function(k, i) {\n    columnWidths[i] = k.length;\n    for (var j = 0; j < rows.length; j++) {\n      var cellStr = (rows[j][k] || '?').toString();\n      stringRows[j] = stringRows[j] || [];\n      stringRows[j][i] = cellStr;\n      columnWidths[i] = Math.max(columnWidths[i], cellStr.length);\n    }\n  });\n\n  // Join all elements in the row into a single string with | separators\n  // (appends extra spaces to each cell to make separators  | aligned)\n  function joinRow(row, space) {\n    var cells = row.map(function(cell, i) {\n      var extraSpaces = repeat(' ', columnWidths[i] - cell.length).join('');\n      return cell + extraSpaces;\n    });\n    space = space || ' ';\n    return cells.join(space + '|' + space);\n  }\n\n  var separators = columnWidths.map(function(columnWidth) {\n    return repeat('-', columnWidth).join('');\n  });\n  var separatorRow = joinRow(separators, '-');\n  var header = joinRow(columns);\n  var table = [header, separatorRow];\n\n  for (var i = 0; i < rows.length; i++) {\n    table.push(joinRow(stringRows[i]));\n  }\n\n  // Notice extra empty line at the beginning.\n  // Native logging hook adds \"RCTLog >\" at the front of every\n  // logged string, which would shift the header and screw up\n  // the table\n  global.nativeLoggingHook('\\n' + table.join('\\n'), LOG_LEVELS.info);\n}\n\nconst GROUP_PAD = '\\u2502'; // Box light vertical\nconst GROUP_OPEN = '\\u2510'; // Box light down+left\nconst GROUP_CLOSE = '\\u2518'; // Box light up+left\n\nconst groupStack = [];\n\nfunction groupFormat(prefix, msg) {\n  // Insert group formatting before the console message\n  return groupStack.join('') + prefix + ' ' + (msg || '');\n}\n\nfunction consoleGroupPolyfill(label) {\n  global.nativeLoggingHook(groupFormat(GROUP_OPEN, label), LOG_LEVELS.info);\n  groupStack.push(GROUP_PAD);\n}\n\nfunction consoleGroupCollapsedPolyfill(label) {\n  global.nativeLoggingHook(groupFormat(GROUP_CLOSE, label), LOG_LEVELS.info);\n  groupStack.push(GROUP_PAD);\n}\n\nfunction consoleGroupEndPolyfill() {\n  groupStack.pop();\n  global.nativeLoggingHook(groupFormat(GROUP_CLOSE), LOG_LEVELS.info);\n}\n\nfunction consoleAssertPolyfill(expression, label) {\n  if (!expression) {\n    global.nativeLoggingHook('Assertion failed: ' + label, LOG_LEVELS.error);\n  }\n}\n\nif (global.nativeLoggingHook) {\n  const originalConsole = global.console;\n  // Preserve the original `console` as `originalConsole`\n  if (__DEV__ && originalConsole) {\n    const descriptor = Object.getOwnPropertyDescriptor(global, 'console');\n    if (descriptor) {\n      Object.defineProperty(global, 'originalConsole', descriptor);\n    }\n  }\n\n  global.console = {\n    error: getNativeLogFunction(LOG_LEVELS.error),\n    info: getNativeLogFunction(LOG_LEVELS.info),\n    log: getNativeLogFunction(LOG_LEVELS.info),\n    warn: getNativeLogFunction(LOG_LEVELS.warn),\n    trace: getNativeLogFunction(LOG_LEVELS.trace),\n    debug: getNativeLogFunction(LOG_LEVELS.trace),\n    table: consoleTablePolyfill,\n    group: consoleGroupPolyfill,\n    groupEnd: consoleGroupEndPolyfill,\n    groupCollapsed: consoleGroupCollapsedPolyfill,\n    assert: consoleAssertPolyfill,\n  };\n\n  Object.defineProperty(console, '_isPolyfilled', {\n    value: true,\n    enumerable: false,\n  });\n\n  // If available, also call the original `console` method since that is\n  // sometimes useful. Ex: on OS X, this will let you see rich output in\n  // the Safari Web Inspector console.\n  if (__DEV__ && originalConsole) {\n    Object.keys(console).forEach(methodName => {\n      const reactNativeMethod = console[methodName];\n      if (originalConsole[methodName]) {\n        console[methodName] = function() {\n          originalConsole[methodName](...arguments);\n          reactNativeMethod.apply(console, arguments);\n        };\n      }\n    });\n\n    // The following methods are not supported by this polyfill but\n    // we still should pass them to original console if they are\n    // supported by it.\n    ['clear', 'dir', 'dirxml', 'profile', 'profileEnd'].forEach(methodName => {\n      if (typeof originalConsole[methodName] === 'function') {\n        console[methodName] = function() {\n          originalConsole[methodName](...arguments);\n        };\n      }\n    });\n  }\n} else if (!global.console) {\n  function stub() {}\n  const log = global.print || stub;\n\n  global.console = {\n    debug: log,\n    error: log,\n    info: log,\n    log: log,\n    trace: log,\n    warn: log,\n    assert(expression, label) {\n      if (!expression) {\n        log('Assertion failed: ' + label);\n      }\n    },\n    clear: stub,\n    dir: stub,\n    dirxml: stub,\n    group: stub,\n    groupCollapsed: stub,\n    groupEnd: stub,\n    profile: stub,\n    profileEnd: stub,\n    table: stub,\n  };\n\n  Object.defineProperty(console, '_isPolyfilled', {\n    value: true,\n    enumerable: false,\n  });\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict\n * @polyfill\n */\n\nlet _inGuard = 0;\n\ntype ErrorHandler = (error: mixed, isFatal: boolean) => void;\ntype Fn<Args, Return> = (...Args) => Return;\n\n/**\n * This is the error handler that is called when we encounter an exception\n * when loading a module. This will report any errors encountered before\n * ExceptionsManager is configured.\n */\nlet _globalHandler: ErrorHandler = function onError(\n  e: mixed,\n  isFatal: boolean,\n) {\n  throw e;\n};\n\n/**\n * The particular require runtime that we are using looks for a global\n * `ErrorUtils` object and if it exists, then it requires modules with the\n * error handler specified via ErrorUtils.setGlobalHandler by calling the\n * require function with applyWithGuard. Since the require module is loaded\n * before any of the modules, this ErrorUtils must be defined (and the handler\n * set) globally before requiring anything.\n */\nconst ErrorUtils = {\n  setGlobalHandler(fun: ErrorHandler): void {\n    _globalHandler = fun;\n  },\n  getGlobalHandler(): ErrorHandler {\n    return _globalHandler;\n  },\n  reportError(error: mixed): void {\n    _globalHandler && _globalHandler(error, false);\n  },\n  reportFatalError(error: mixed): void {\n    // NOTE: This has an untyped call site in Metro.\n    _globalHandler && _globalHandler(error, true);\n  },\n  applyWithGuard<TArgs: $ReadOnlyArray<mixed>, TOut>(\n    fun: Fn<TArgs, TOut>,\n    context?: ?mixed,\n    args?: ?TArgs,\n    // Unused, but some code synced from www sets it to null.\n    unused_onError?: null,\n    // Some callers pass a name here, which we ignore.\n    unused_name?: ?string,\n  ): ?TOut {\n    try {\n      _inGuard++;\n      /* $FlowFixMe[incompatible-call] : TODO T48204745 (1) apply(context,\n       * null) is fine. (2) array -> rest array should work */\n      /* $FlowFixMe[incompatible-type] : TODO T48204745 (1) apply(context,\n       * null) is fine. (2) array -> rest array should work */\n      return fun.apply(context, args);\n    } catch (e) {\n      ErrorUtils.reportError(e);\n    } finally {\n      _inGuard--;\n    }\n    return null;\n  },\n  applyWithGuardIfNeeded<TArgs: $ReadOnlyArray<mixed>, TOut>(\n    fun: Fn<TArgs, TOut>,\n    context?: ?mixed,\n    args?: ?TArgs,\n  ): ?TOut {\n    if (ErrorUtils.inGuard()) {\n      /* $FlowFixMe[incompatible-call] : TODO T48204745 (1) apply(context,\n       * null) is fine. (2) array -> rest array should work */\n      /* $FlowFixMe[incompatible-type] : TODO T48204745 (1) apply(context,\n       * null) is fine. (2) array -> rest array should work */\n      return fun.apply(context, args);\n    } else {\n      ErrorUtils.applyWithGuard(fun, context, args);\n    }\n    return null;\n  },\n  inGuard(): boolean {\n    return !!_inGuard;\n  },\n  guard<TArgs: $ReadOnlyArray<mixed>, TOut>(\n    fun: Fn<TArgs, TOut>,\n    name?: ?string,\n    context?: ?mixed,\n  ): ?(...TArgs) => ?TOut {\n    // TODO: (moti) T48204753 Make sure this warning is never hit and remove it - types\n    // should be sufficient.\n    if (typeof fun !== 'function') {\n      console.warn('A function must be passed to ErrorUtils.guard, got ', fun);\n      return null;\n    }\n    const guardName = name ?? fun.name ?? '<generated guard>';\n    function guarded(...args: TArgs): ?TOut {\n      return ErrorUtils.applyWithGuard(\n        fun,\n        context ?? this,\n        args,\n        null,\n        guardName,\n      );\n    }\n\n    return guarded;\n  },\n};\n\nglobal.ErrorUtils = ErrorUtils;\n\nexport type ErrorUtilsT = typeof ErrorUtils;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @polyfill\n * @nolint\n */\n\n(function() {\n  'use strict';\n\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  /**\n   * Returns an array of the given object's own enumerable entries.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\n   */\n  if (typeof Object.entries !== 'function') {\n    Object.entries = function(object) {\n      // `null` and `undefined` values are not allowed.\n      if (object == null) {\n        throw new TypeError('Object.entries called on non-object');\n      }\n\n      const entries = [];\n      for (const key in object) {\n        if (hasOwnProperty.call(object, key)) {\n          entries.push([key, object[key]]);\n        }\n      }\n      return entries;\n    };\n  }\n\n  /**\n   * Returns an array of the given object's own enumerable entries.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\n   */\n  if (typeof Object.values !== 'function') {\n    Object.values = function(object) {\n      // `null` and `undefined` values are not allowed.\n      if (object == null) {\n        throw new TypeError('Object.values called on non-object');\n      }\n\n      const values = [];\n      for (const key in object) {\n        if (hasOwnProperty.call(object, key)) {\n          values.push(object[key]);\n        }\n      }\n      return values;\n    };\n  }\n})();\n","import '@tarojs/rn-supporter/entry-file.js'",""],"x_facebook_sources":[null,[{"names":["<global>","global.$RefreshReg$","global.$RefreshSig$","<anonymous>","clear","define","metroRequire","initializingModuleIds.slice.map$argument_0","shouldPrintRequireCycle","isIgnored","regExps.some$argument_0","modules.every$argument_0","metroImportDefault","metroImportAll","fallbackRequireContext","guardedLoadModule","unpackModuleId","packModuleId","registerSegment","moduleIds.forEach$argument_0","loadModuleImplementation","unknownModuleError","moduleThrewError","metroRequire.Systrace.beginEvent","metroRequire.Systrace.endEvent","metroRequire.getModules","createHotReloadingObject","hot.accept","hot.dispose","metroHotUpdateModule","topologicalSort$argument_1","topologicalSort$argument_2","setTimeout$argument_0","topologicalSort","traverseDependentNodes","dependentNodes.forEach$argument_0","roots.forEach$argument_0","runUpdatedModule","performFullRefresh","isReactRefreshBoundary","shouldInvalidateReactRefreshBoundary","getRefreshBoundarySignature","registerExportsForReactRefresh","requireSystrace","requireRefresh"],"mappings":"AAA;wBCyB,QD;wBEE,MC,cH;AIG;CJM;AKO;CL2C;AME;aCyB,6DD;CNkB;AQG;oBCQ;mCCC,+BD,CD;uBGE,8BH;CRC;AYE;CZoB;AaI;CbmC;uBcM;CdU;AeI;CfiB;AgBK;ChBO;AiBI;CjBE;AkBM;sBCmB;KDI;ClBE;AoBE;8BnBgE;SmBE;CpBuD;AqBE;CrBU;AsBE;CtBK;gBuBI,QvB;cwBC,QxB;4ByBG;GzBE;iC0BE;cCK;ODG;eEC;OFE;G1BG;+B6BI;QCiD;SDoD;QEC,gBF;yCGwH;SHI;G7BG;0BiCE;ICK;6BCkB;ODE;KDG;kBGE;KHE;GjCE;2BqCE;GrCuE;6BsCE;GtC0C;+BuCE;GvCmC;6CwCE;GxCmB;oCyCE;GzC2B;uC0CE;G1CqB;wB2CW;G3CI;uB4CE;G5CI"}],[{"names":["<global>","<anonymous>","inspect","stylizeNoColor","arrayToHash","array.forEach$argument_0","formatValue","keys.map$argument_0","formatPrimitive","formatError","formatArray","keys.forEach$argument_0","formatProperty","str.split.map$argument_0","reduceToSingleString","output.reduce$argument_0","isArray","isBoolean","isNull","isNullOrUndefined","isNumber","isString","isSymbol","isUndefined","isRegExp","isObject","isDate","isError","isFunction","objectToString","hasOwnProperty","getNativeLogFunction","Array.prototype.map.call$argument_1","repeat","Array.apply.map$argument_0","consoleTablePolyfill","columns.forEach$argument_0","joinRow","row.map$argument_0","columnWidths.map$argument_0","groupFormat","consoleGroupPolyfill","consoleGroupCollapsedPolyfill","consoleGroupEndPolyfill","consoleAssertPolyfill","Object.keys.forEach$argument_0","methodName","forEach$argument_0","stub","global.console.assert"],"mappings":"AAA;iBCiB;ECwB;GDO;EEE;GFE;EGE;kBCG;KDE;GHG;EKE;wBC2F;ODS;GLM;EOE;GPgB;EQE;GRE;ESE;iBCkB;KDM;GTE;EWE;mBC4B;eDE;qBCQ;iBDE;GX0B;EaE;+BCE;KDI;Gbc;EeI;GfE;EgBE;GhBE;EiBE;GjBE;EkBE;GlBE;EmBE;GnBE;EoBE;GpBE;EqBE;GrBE;EsBE;GtBE;EuBE;GvBE;EwBE;GxBE;EyBE;GzBE;E0BE;G1BK;E2BE;G3BE;E4BE;G5BE;E6BE;G7BE;CDG;A+BmB;S9BC;yB+BM;S/BE;G8BmC;C/BC;AiCE;yCCC;GDE;CjCC;AmCE;kBCwB;GDQ;EEI;wBCC;KDG;GFG;oCIE;GJE;CnCc;AwCQ;CxCG;AyCE;CzCG;A0CE;C1CG;A2CE;C3CG;A4CE;C5CI;iC6CmC;8BCG;SDG;K7CE;gE+CK;8BDE;SCE;K/CE;EgDG,kBhD;IiDU;KjDI"}],[{"names":["<global>","onError","ErrorUtils.setGlobalHandler","ErrorUtils.getGlobalHandler","ErrorUtils.reportError","ErrorUtils.reportFatalError","ErrorUtils.applyWithGuard","ErrorUtils.applyWithGuardIfNeeded","ErrorUtils.inGuard","ErrorUtils.guard","guarded"],"mappings":"AAA;mCCqB;CDK;EEW;GFE;EGC;GHE;EIC;GJE;EKC;GLG;EMC;GNsB;EOC;GPe;EQC;GRE;ESC;ICY;KDQ;GTG"}],[{"names":["<global>","<anonymous>","entries","values"],"mappings":"AAA;CCW;qBCU;KDa;oBEQ;KFa;CDE"}],[{"names":["<global>"],"mappings":"AAA"}],[{"names":[],"mappings":""}]],"names":["global","__r","metroRequire","__METRO_GLOBAL_PREFIX__","factory","moduleId","dependencyMap","modules","mod","hasError","importedAll","EMPTY","importedDefault","isInitialized","publicModule","exports","__c","clear","__registerSegment","segmentId","moduleDefiner","moduleIds","moduleDefinersBySegmentID","forEach","definingSegmentByModuleID","has","set","hasOwnProperty","Object","create","moduleIdReallyIsNumber","module","guardedLoadModule","metroImportDefault","__esModule","default","metroImportAll","key","call","importDefault","importAll","context","Error","inGuard","ErrorUtils","returnValue","loadModuleImplementation","e","reportFatalError","ID_MASK_SHIFT","LOCAL_ID_MASK","unpackModuleId","localId","packModuleId","value","Map","length","_definingSegmentByMod","get","undefined","definer","delete","nativeRequire","_unpackModuleId","moduleThrewError","error","_module","moduleObject","id","globalThis","window","this","inspect","stylizeNoColor","str","arrayToHash","array","hash","val","formatValue","ctx","recurseTimes","formatValueCalls","primitive","formatPrimitive","keys","visibleKeys","isError","indexOf","formatError","isFunction","name","stylize","isRegExp","RegExp","prototype","toString","isDate","Date","ar","output","base","braces","Array","isArray","toUTCString","seen","push","formatArray","map","formatProperty","pop","reduceToSingleString","isUndefined","simple","JSON","stringify","replace","isNumber","isBoolean","isNull","i","l","String","match","desc","getOwnPropertyDescriptor","split","line","join","substr","reduce","prev","cur","numLinesEst","arg","re","isObject","objectToString","d","o","obj","prop","opts","depth","OBJECT_COLUMN_NAME","LOG_LEVELS","trace","info","warn","INSPECTOR_LEVELS","INSPECTOR_FRAMES_TO_SKIP","getNativeLogFunction","level","arguments","firstArg","logLevel","slice","__inspectorLog","groupStack","groupFormat","nativeLoggingHook","repeat","element","n","apply","GROUP_PAD","GROUP_OPEN","GROUP_CLOSE","prefix","msg","console","log","debug","table","rows","data","row","columns","sort","stringRows","columnWidths","k","j","cellStr","Math","max","separatorRow","joinRow","columnWidth","space","cells","cell","group","label","groupEnd","groupCollapsed","assert","expression","defineProperty","enumerable","stub","print","dir","dirxml","profile","profileEnd","_inGuard","_globalHandler","setGlobalHandler","fun","getGlobalHandler","reportError","applyWithGuard","args","applyWithGuardIfNeeded","guard","_ref","guardName","_len","_key","entries","object","TypeError","values","r"],"mappings":"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"}