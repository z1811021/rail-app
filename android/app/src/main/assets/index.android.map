{"version":3,"sources":["__prelude__","/Users/gongxi33/dev/outsource/rail/rail-app/rail-all/node_modules/metro-runtime/src/polyfills/require.js","/Users/gongxi33/dev/outsource/rail/rail-app/rail-all/node_modules/@react-native/polyfills/console.js","/Users/gongxi33/dev/outsource/rail/rail-app/rail-all/node_modules/@react-native/polyfills/error-guard.js","/Users/gongxi33/dev/outsource/rail/rail-app/rail-all/node_modules/@react-native/polyfills/Object.es8.js","/Users/gongxi33/dev/outsource/rail/rail-app/rail-all/index.js","/Users/gongxi33/dev/outsource/rail/rail-app/rail-all/node_modules/@tarojs/rn-supporter/entry-file.js"],"sourcesContent":["var __BUNDLE_START_TIME__=this.nativePerformanceNow?nativePerformanceNow():Date.now(),__DEV__=false,process=this.process||{},__METRO_GLOBAL_PREFIX__='';process.env=process.env||{};process.env.NODE_ENV=process.env.NODE_ENV||\"production\";","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n * @oncall react_native\n * @polyfill\n */\n\n\"use strict\";\n\n/* eslint-disable no-bitwise */\n// A simpler $ArrayLike<T>. Not iterable and doesn't have a `length`.\n// This is compatible with actual arrays as well as with objects that look like\n// {0: 'value', 1: '...'}\nglobal.__r = metroRequire;\nglobal[`${__METRO_GLOBAL_PREFIX__}__d`] = define;\nglobal.__c = clear;\nglobal.__registerSegment = registerSegment;\nvar modules = clear();\n\n// Don't use a Symbol here, it would pull in an extra polyfill with all sorts of\n// additional stuff (e.g. Array.from).\nconst EMPTY = {};\nconst CYCLE_DETECTED = {};\nconst { hasOwnProperty } = {};\nif (__DEV__) {\n  global.$RefreshReg$ = () => {};\n  global.$RefreshSig$ = () => (type) => type;\n}\nfunction clear() {\n  modules = Object.create(null);\n\n  // We return modules here so that we can assign an initial value to modules\n  // when defining it. Otherwise, we would have to do \"let modules = null\",\n  // which will force us to add \"nullthrows\" everywhere.\n  return modules;\n}\nif (__DEV__) {\n  var verboseNamesToModuleIds = Object.create(null);\n  var initializingModuleIds = [];\n}\nfunction define(factory, moduleId, dependencyMap) {\n  if (modules[moduleId] != null) {\n    if (__DEV__) {\n      // (We take `inverseDependencies` from `arguments` to avoid an unused\n      // named parameter in `define` in production.\n      const inverseDependencies = arguments[4];\n\n      // If the module has already been defined and the define method has been\n      // called with inverseDependencies, we can hot reload it.\n      if (inverseDependencies) {\n        global.__accept(moduleId, factory, dependencyMap, inverseDependencies);\n      }\n    }\n\n    // prevent repeated calls to `global.nativeRequire` to overwrite modules\n    // that are already loaded\n    return;\n  }\n  const mod = {\n    dependencyMap,\n    factory,\n    hasError: false,\n    importedAll: EMPTY,\n    importedDefault: EMPTY,\n    isInitialized: false,\n    publicModule: {\n      exports: {},\n    },\n  };\n  modules[moduleId] = mod;\n  if (__DEV__) {\n    // HMR\n    mod.hot = createHotReloadingObject();\n\n    // DEBUGGABLE MODULES NAMES\n    // we take `verboseName` from `arguments` to avoid an unused named parameter\n    // in `define` in production.\n    const verboseName = arguments[3];\n    if (verboseName) {\n      mod.verboseName = verboseName;\n      verboseNamesToModuleIds[verboseName] = moduleId;\n    }\n  }\n}\nfunction metroRequire(moduleId) {\n  if (__DEV__ && typeof moduleId === \"string\") {\n    const verboseName = moduleId;\n    moduleId = verboseNamesToModuleIds[verboseName];\n    if (moduleId == null) {\n      throw new Error(`Unknown named module: \"${verboseName}\"`);\n    } else {\n      console.warn(\n        `Requiring module \"${verboseName}\" by name is only supported for ` +\n          \"debugging purposes and will BREAK IN PRODUCTION!\"\n      );\n    }\n  }\n\n  //$FlowFixMe: at this point we know that moduleId is a number\n  const moduleIdReallyIsNumber = moduleId;\n  if (__DEV__) {\n    const initializingIndex = initializingModuleIds.indexOf(\n      moduleIdReallyIsNumber\n    );\n    if (initializingIndex !== -1) {\n      const cycle = initializingModuleIds\n        .slice(initializingIndex)\n        .map((id) => (modules[id] ? modules[id].verboseName : \"[unknown]\"));\n      if (shouldPrintRequireCycle(cycle)) {\n        cycle.push(cycle[0]); // We want to print A -> B -> A:\n        console.warn(\n          `Require cycle: ${cycle.join(\" -> \")}\\n\\n` +\n            \"Require cycles are allowed, but can result in uninitialized values. \" +\n            \"Consider refactoring to remove the need for a cycle.\"\n        );\n      }\n    }\n  }\n  const module = modules[moduleIdReallyIsNumber];\n  return module && module.isInitialized\n    ? module.publicModule.exports\n    : guardedLoadModule(moduleIdReallyIsNumber, module);\n}\n\n// We print require cycles unless they match a pattern in the\n// `requireCycleIgnorePatterns` configuration.\nfunction shouldPrintRequireCycle(modules) {\n  const regExps =\n    global[__METRO_GLOBAL_PREFIX__ + \"__requireCycleIgnorePatterns\"];\n  if (!Array.isArray(regExps)) {\n    return true;\n  }\n  const isIgnored = (module) =>\n    module != null && regExps.some((regExp) => regExp.test(module));\n\n  // Print the cycle unless any part of it is ignored\n  return modules.every((module) => !isIgnored(module));\n}\nfunction metroImportDefault(moduleId) {\n  if (__DEV__ && typeof moduleId === \"string\") {\n    const verboseName = moduleId;\n    moduleId = verboseNamesToModuleIds[verboseName];\n  }\n\n  //$FlowFixMe: at this point we know that moduleId is a number\n  const moduleIdReallyIsNumber = moduleId;\n  if (\n    modules[moduleIdReallyIsNumber] &&\n    modules[moduleIdReallyIsNumber].importedDefault !== EMPTY\n  ) {\n    return modules[moduleIdReallyIsNumber].importedDefault;\n  }\n  const exports = metroRequire(moduleIdReallyIsNumber);\n  const importedDefault =\n    exports && exports.__esModule ? exports.default : exports;\n\n  // $FlowFixMe The metroRequire call above will throw if modules[id] is null\n  return (modules[moduleIdReallyIsNumber].importedDefault = importedDefault);\n}\nmetroRequire.importDefault = metroImportDefault;\nfunction metroImportAll(moduleId) {\n  if (__DEV__ && typeof moduleId === \"string\") {\n    const verboseName = moduleId;\n    moduleId = verboseNamesToModuleIds[verboseName];\n  }\n\n  //$FlowFixMe: at this point we know that moduleId is a number\n  const moduleIdReallyIsNumber = moduleId;\n  if (\n    modules[moduleIdReallyIsNumber] &&\n    modules[moduleIdReallyIsNumber].importedAll !== EMPTY\n  ) {\n    return modules[moduleIdReallyIsNumber].importedAll;\n  }\n  const exports = metroRequire(moduleIdReallyIsNumber);\n  let importedAll;\n  if (exports && exports.__esModule) {\n    importedAll = exports;\n  } else {\n    importedAll = {};\n\n    // Refrain from using Object.assign, it has to work in ES3 environments.\n    if (exports) {\n      for (const key in exports) {\n        if (hasOwnProperty.call(exports, key)) {\n          importedAll[key] = exports[key];\n        }\n      }\n    }\n    importedAll.default = exports;\n  }\n\n  // $FlowFixMe The metroRequire call above will throw if modules[id] is null\n  return (modules[moduleIdReallyIsNumber].importedAll = importedAll);\n}\nmetroRequire.importAll = metroImportAll;\n\n// The `require.context()` syntax is never executed in the runtime because it is converted\n// to `require()` in `metro/src/ModuleGraph/worker/collectDependencies.js` after collecting\n// dependencies. If the feature flag is not enabled then the conversion never takes place and this error is thrown (development only).\nmetroRequire.context = function fallbackRequireContext() {\n  if (__DEV__) {\n    throw new Error(\n      \"The experimental Metro feature `require.context` is not enabled in your project.\\nThis can be enabled by setting the `transformer.unstable_allowRequireContext` property to `true` in your Metro configuration.\"\n    );\n  }\n  throw new Error(\n    \"The experimental Metro feature `require.context` is not enabled in your project.\"\n  );\n};\nlet inGuard = false;\nfunction guardedLoadModule(moduleId, module) {\n  if (!inGuard && global.ErrorUtils) {\n    inGuard = true;\n    let returnValue;\n    try {\n      returnValue = loadModuleImplementation(moduleId, module);\n    } catch (e) {\n      // TODO: (moti) T48204692 Type this use of ErrorUtils.\n      global.ErrorUtils.reportFatalError(e);\n    }\n    inGuard = false;\n    return returnValue;\n  } else {\n    return loadModuleImplementation(moduleId, module);\n  }\n}\nconst ID_MASK_SHIFT = 16;\nconst LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;\nfunction unpackModuleId(moduleId) {\n  const segmentId = moduleId >>> ID_MASK_SHIFT;\n  const localId = moduleId & LOCAL_ID_MASK;\n  return {\n    segmentId,\n    localId,\n  };\n}\nmetroRequire.unpackModuleId = unpackModuleId;\nfunction packModuleId(value) {\n  return (value.segmentId << ID_MASK_SHIFT) + value.localId;\n}\nmetroRequire.packModuleId = packModuleId;\nconst moduleDefinersBySegmentID = [];\nconst definingSegmentByModuleID = new Map();\nfunction registerSegment(segmentId, moduleDefiner, moduleIds) {\n  moduleDefinersBySegmentID[segmentId] = moduleDefiner;\n  if (__DEV__) {\n    if (segmentId === 0 && moduleIds) {\n      throw new Error(\n        \"registerSegment: Expected moduleIds to be null for main segment\"\n      );\n    }\n    if (segmentId !== 0 && !moduleIds) {\n      throw new Error(\n        \"registerSegment: Expected moduleIds to be passed for segment #\" +\n          segmentId\n      );\n    }\n  }\n  if (moduleIds) {\n    moduleIds.forEach((moduleId) => {\n      if (!modules[moduleId] && !definingSegmentByModuleID.has(moduleId)) {\n        definingSegmentByModuleID.set(moduleId, segmentId);\n      }\n    });\n  }\n}\nfunction loadModuleImplementation(moduleId, module) {\n  if (!module && moduleDefinersBySegmentID.length > 0) {\n    var _definingSegmentByMod;\n    const segmentId =\n      (_definingSegmentByMod = definingSegmentByModuleID.get(moduleId)) !==\n        null && _definingSegmentByMod !== void 0\n        ? _definingSegmentByMod\n        : 0;\n    const definer = moduleDefinersBySegmentID[segmentId];\n    if (definer != null) {\n      definer(moduleId);\n      module = modules[moduleId];\n      definingSegmentByModuleID.delete(moduleId);\n    }\n  }\n  const nativeRequire = global.nativeRequire;\n  if (!module && nativeRequire) {\n    const { segmentId, localId } = unpackModuleId(moduleId);\n    nativeRequire(localId, segmentId);\n    module = modules[moduleId];\n  }\n  if (!module) {\n    throw unknownModuleError(moduleId);\n  }\n  if (module.hasError) {\n    throw module.error;\n  }\n  if (__DEV__) {\n    var Systrace = requireSystrace();\n    var Refresh = requireRefresh();\n  }\n\n  // We must optimistically mark module as initialized before running the\n  // factory to keep any require cycles inside the factory from causing an\n  // infinite require loop.\n  module.isInitialized = true;\n  const { factory, dependencyMap } = module;\n  if (__DEV__) {\n    initializingModuleIds.push(moduleId);\n  }\n  try {\n    if (__DEV__) {\n      // $FlowIgnore: we know that __DEV__ is const and `Systrace` exists\n      Systrace.beginEvent(\"JS_require_\" + (module.verboseName || moduleId));\n    }\n    const moduleObject = module.publicModule;\n    if (__DEV__) {\n      moduleObject.hot = module.hot;\n      var prevRefreshReg = global.$RefreshReg$;\n      var prevRefreshSig = global.$RefreshSig$;\n      if (Refresh != null) {\n        const RefreshRuntime = Refresh;\n        global.$RefreshReg$ = (type, id) => {\n          RefreshRuntime.register(type, moduleId + \" \" + id);\n        };\n        global.$RefreshSig$ =\n          RefreshRuntime.createSignatureFunctionForTransform;\n      }\n    }\n    moduleObject.id = moduleId;\n\n    // keep args in sync with with defineModuleCode in\n    // metro/src/Resolver/index.js\n    // and metro/src/ModuleGraph/worker.js\n    factory(\n      global,\n      metroRequire,\n      metroImportDefault,\n      metroImportAll,\n      moduleObject,\n      moduleObject.exports,\n      dependencyMap\n    );\n\n    // avoid removing factory in DEV mode as it breaks HMR\n    if (!__DEV__) {\n      // $FlowFixMe: This is only sound because we never access `factory` again\n      module.factory = undefined;\n      module.dependencyMap = undefined;\n    }\n    if (__DEV__) {\n      // $FlowIgnore: we know that __DEV__ is const and `Systrace` exists\n      Systrace.endEvent();\n      if (Refresh != null) {\n        registerExportsForReactRefresh(Refresh, moduleObject.exports, moduleId);\n      }\n    }\n    return moduleObject.exports;\n  } catch (e) {\n    module.hasError = true;\n    module.error = e;\n    module.isInitialized = false;\n    module.publicModule.exports = undefined;\n    throw e;\n  } finally {\n    if (__DEV__) {\n      if (initializingModuleIds.pop() !== moduleId) {\n        throw new Error(\n          \"initializingModuleIds is corrupt; something is terribly wrong\"\n        );\n      }\n      global.$RefreshReg$ = prevRefreshReg;\n      global.$RefreshSig$ = prevRefreshSig;\n    }\n  }\n}\nfunction unknownModuleError(id) {\n  let message = 'Requiring unknown module \"' + id + '\".';\n  if (__DEV__) {\n    message +=\n      \" If you are sure the module exists, try restarting Metro. \" +\n      \"You may also want to run `yarn` or `npm install`.\";\n  }\n  return Error(message);\n}\nif (__DEV__) {\n  // $FlowFixMe[prop-missing]\n  metroRequire.Systrace = {\n    beginEvent: () => {},\n    endEvent: () => {},\n  };\n  // $FlowFixMe[prop-missing]\n  metroRequire.getModules = () => {\n    return modules;\n  };\n\n  // HOT MODULE RELOADING\n  var createHotReloadingObject = function () {\n    const hot = {\n      _acceptCallback: null,\n      _disposeCallback: null,\n      _didAccept: false,\n      accept: (callback) => {\n        hot._didAccept = true;\n        hot._acceptCallback = callback;\n      },\n      dispose: (callback) => {\n        hot._disposeCallback = callback;\n      },\n    };\n    return hot;\n  };\n  let reactRefreshTimeout = null;\n  const metroHotUpdateModule = function (\n    id,\n    factory,\n    dependencyMap,\n    inverseDependencies\n  ) {\n    const mod = modules[id];\n    if (!mod) {\n      if (factory) {\n        // New modules are going to be handled by the define() method.\n        return;\n      }\n      throw unknownModuleError(id);\n    }\n    if (!mod.hasError && !mod.isInitialized) {\n      // The module hasn't actually been executed yet,\n      // so we can always safely replace it.\n      mod.factory = factory;\n      mod.dependencyMap = dependencyMap;\n      return;\n    }\n    const Refresh = requireRefresh();\n    const refreshBoundaryIDs = new Set();\n\n    // In this loop, we will traverse the dependency tree upwards from the\n    // changed module. Updates \"bubble\" up to the closest accepted parent.\n    //\n    // If we reach the module root and nothing along the way accepted the update,\n    // we know hot reload is going to fail. In that case we return false.\n    //\n    // The main purpose of this loop is to figure out whether it's safe to apply\n    // a hot update. It is only safe when the update was accepted somewhere\n    // along the way upwards for each of its parent dependency module chains.\n    //\n    // We perform a topological sort because we may discover the same\n    // module more than once in the list of things to re-execute, and\n    // we want to execute modules before modules that depend on them.\n    //\n    // If we didn't have this check, we'd risk re-evaluating modules that\n    // have side effects and lead to confusing and meaningless crashes.\n\n    let didBailOut = false;\n    let updatedModuleIDs;\n    try {\n      updatedModuleIDs = topologicalSort(\n        [id],\n        // Start with the changed module and go upwards\n        (pendingID) => {\n          const pendingModule = modules[pendingID];\n          if (pendingModule == null) {\n            // Nothing to do.\n            return [];\n          }\n          const pendingHot = pendingModule.hot;\n          if (pendingHot == null) {\n            throw new Error(\n              \"[Refresh] Expected module.hot to always exist in DEV.\"\n            );\n          }\n          // A module can be accepted manually from within itself.\n          let canAccept = pendingHot._didAccept;\n          if (!canAccept && Refresh != null) {\n            // Or React Refresh may mark it accepted based on exports.\n            const isBoundary = isReactRefreshBoundary(\n              Refresh,\n              pendingModule.publicModule.exports\n            );\n            if (isBoundary) {\n              canAccept = true;\n              refreshBoundaryIDs.add(pendingID);\n            }\n          }\n          if (canAccept) {\n            // Don't look at parents.\n            return [];\n          }\n          // If we bubble through the roof, there is no way to do a hot update.\n          // Bail out altogether. This is the failure case.\n          const parentIDs = inverseDependencies[pendingID];\n          if (parentIDs.length === 0) {\n            // Reload the app because the hot reload can't succeed.\n            // This should work both on web and React Native.\n            performFullRefresh(\"No root boundary\", {\n              source: mod,\n              failed: pendingModule,\n            });\n            didBailOut = true;\n            return [];\n          }\n          // This module can't handle the update but maybe all its parents can?\n          // Put them all in the queue to run the same set of checks.\n          return parentIDs;\n        },\n        () => didBailOut // Should we stop?\n      ).reverse();\n    } catch (e) {\n      if (e === CYCLE_DETECTED) {\n        performFullRefresh(\"Dependency cycle\", {\n          source: mod,\n        });\n        return;\n      }\n      throw e;\n    }\n    if (didBailOut) {\n      return;\n    }\n\n    // If we reached here, it is likely that hot reload will be successful.\n    // Run the actual factories.\n    const seenModuleIDs = new Set();\n    for (let i = 0; i < updatedModuleIDs.length; i++) {\n      const updatedID = updatedModuleIDs[i];\n      if (seenModuleIDs.has(updatedID)) {\n        continue;\n      }\n      seenModuleIDs.add(updatedID);\n      const updatedMod = modules[updatedID];\n      if (updatedMod == null) {\n        throw new Error(\"[Refresh] Expected to find the updated module.\");\n      }\n      const prevExports = updatedMod.publicModule.exports;\n      const didError = runUpdatedModule(\n        updatedID,\n        updatedID === id ? factory : undefined,\n        updatedID === id ? dependencyMap : undefined\n      );\n      const nextExports = updatedMod.publicModule.exports;\n      if (didError) {\n        // The user was shown a redbox about module initialization.\n        // There's nothing for us to do here until it's fixed.\n        return;\n      }\n      if (refreshBoundaryIDs.has(updatedID)) {\n        // Since we just executed the code for it, it's possible\n        // that the new exports make it ineligible for being a boundary.\n        const isNoLongerABoundary = !isReactRefreshBoundary(\n          Refresh,\n          nextExports\n        );\n        // It can also become ineligible if its exports are incompatible\n        // with the previous exports.\n        // For example, if you add/remove/change exports, we'll want\n        // to re-execute the importing modules, and force those components\n        // to re-render. Similarly, if you convert a class component\n        // to a function, we want to invalidate the boundary.\n        const didInvalidate = shouldInvalidateReactRefreshBoundary(\n          Refresh,\n          prevExports,\n          nextExports\n        );\n        if (isNoLongerABoundary || didInvalidate) {\n          // We'll be conservative. The only case in which we won't do a full\n          // reload is if all parent modules are also refresh boundaries.\n          // In that case we'll add them to the current queue.\n          const parentIDs = inverseDependencies[updatedID];\n          if (parentIDs.length === 0) {\n            // Looks like we bubbled to the root. Can't recover from that.\n            performFullRefresh(\n              isNoLongerABoundary\n                ? \"No longer a boundary\"\n                : \"Invalidated boundary\",\n              {\n                source: mod,\n                failed: updatedMod,\n              }\n            );\n            return;\n          }\n          // Schedule all parent refresh boundaries to re-run in this loop.\n          for (let j = 0; j < parentIDs.length; j++) {\n            const parentID = parentIDs[j];\n            const parentMod = modules[parentID];\n            if (parentMod == null) {\n              throw new Error(\"[Refresh] Expected to find parent module.\");\n            }\n            const canAcceptParent = isReactRefreshBoundary(\n              Refresh,\n              parentMod.publicModule.exports\n            );\n            if (canAcceptParent) {\n              // All parents will have to re-run too.\n              refreshBoundaryIDs.add(parentID);\n              updatedModuleIDs.push(parentID);\n            } else {\n              performFullRefresh(\"Invalidated boundary\", {\n                source: mod,\n                failed: parentMod,\n              });\n              return;\n            }\n          }\n        }\n      }\n    }\n    if (Refresh != null) {\n      // Debounce a little in case there are multiple updates queued up.\n      // This is also useful because __accept may be called multiple times.\n      if (reactRefreshTimeout == null) {\n        reactRefreshTimeout = setTimeout(() => {\n          reactRefreshTimeout = null;\n          // Update React components.\n          Refresh.performReactRefresh();\n        }, 30);\n      }\n    }\n  };\n  const topologicalSort = function (roots, getEdges, earlyStop) {\n    const result = [];\n    const visited = new Set();\n    const stack = new Set();\n    function traverseDependentNodes(node) {\n      if (stack.has(node)) {\n        throw CYCLE_DETECTED;\n      }\n      if (visited.has(node)) {\n        return;\n      }\n      visited.add(node);\n      stack.add(node);\n      const dependentNodes = getEdges(node);\n      if (earlyStop(node)) {\n        stack.delete(node);\n        return;\n      }\n      dependentNodes.forEach((dependent) => {\n        traverseDependentNodes(dependent);\n      });\n      stack.delete(node);\n      result.push(node);\n    }\n    roots.forEach((root) => {\n      traverseDependentNodes(root);\n    });\n    return result;\n  };\n  const runUpdatedModule = function (id, factory, dependencyMap) {\n    const mod = modules[id];\n    if (mod == null) {\n      throw new Error(\"[Refresh] Expected to find the module.\");\n    }\n    const { hot } = mod;\n    if (!hot) {\n      throw new Error(\"[Refresh] Expected module.hot to always exist in DEV.\");\n    }\n    if (hot._disposeCallback) {\n      try {\n        hot._disposeCallback();\n      } catch (error) {\n        console.error(\n          `Error while calling dispose handler for module ${id}: `,\n          error\n        );\n      }\n    }\n    if (factory) {\n      mod.factory = factory;\n    }\n    if (dependencyMap) {\n      mod.dependencyMap = dependencyMap;\n    }\n    mod.hasError = false;\n    mod.error = undefined;\n    mod.importedAll = EMPTY;\n    mod.importedDefault = EMPTY;\n    mod.isInitialized = false;\n    const prevExports = mod.publicModule.exports;\n    mod.publicModule.exports = {};\n    hot._didAccept = false;\n    hot._acceptCallback = null;\n    hot._disposeCallback = null;\n    metroRequire(id);\n    if (mod.hasError) {\n      // This error has already been reported via a redbox.\n      // We know it's likely a typo or some mistake that was just introduced.\n      // Our goal now is to keep the rest of the application working so that by\n      // the time user fixes the error, the app isn't completely destroyed\n      // underneath the redbox. So we'll revert the module object to the last\n      // successful export and stop propagating this update.\n      mod.hasError = false;\n      mod.isInitialized = true;\n      mod.error = null;\n      mod.publicModule.exports = prevExports;\n      // We errored. Stop the update.\n      return true;\n    }\n    if (hot._acceptCallback) {\n      try {\n        hot._acceptCallback();\n      } catch (error) {\n        console.error(\n          `Error while calling accept handler for module ${id}: `,\n          error\n        );\n      }\n    }\n    // No error.\n    return false;\n  };\n  const performFullRefresh = (reason, modules) => {\n    /* global window */\n    if (\n      typeof window !== \"undefined\" &&\n      window.location != null &&\n      typeof window.location.reload === \"function\"\n    ) {\n      window.location.reload();\n    } else {\n      const Refresh = requireRefresh();\n      if (Refresh != null) {\n        var _modules$source$verbo,\n          _modules$source,\n          _modules$failed$verbo,\n          _modules$failed;\n        const sourceName =\n          (_modules$source$verbo =\n            (_modules$source = modules.source) === null ||\n            _modules$source === void 0\n              ? void 0\n              : _modules$source.verboseName) !== null &&\n          _modules$source$verbo !== void 0\n            ? _modules$source$verbo\n            : \"unknown\";\n        const failedName =\n          (_modules$failed$verbo =\n            (_modules$failed = modules.failed) === null ||\n            _modules$failed === void 0\n              ? void 0\n              : _modules$failed.verboseName) !== null &&\n          _modules$failed$verbo !== void 0\n            ? _modules$failed$verbo\n            : \"unknown\";\n        Refresh.performFullRefresh(\n          `Fast Refresh - ${reason} <${sourceName}> <${failedName}>`\n        );\n      } else {\n        console.warn(\"Could not reload the application after an edit.\");\n      }\n    }\n  };\n\n  // Modules that only export components become React Refresh boundaries.\n  var isReactRefreshBoundary = function (Refresh, moduleExports) {\n    if (Refresh.isLikelyComponentType(moduleExports)) {\n      return true;\n    }\n    if (moduleExports == null || typeof moduleExports !== \"object\") {\n      // Exit if we can't iterate over exports.\n      return false;\n    }\n    let hasExports = false;\n    let areAllExportsComponents = true;\n    for (const key in moduleExports) {\n      hasExports = true;\n      if (key === \"__esModule\") {\n        continue;\n      }\n      const desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n      if (desc && desc.get) {\n        // Don't invoke getters as they may have side effects.\n        return false;\n      }\n      const exportValue = moduleExports[key];\n      if (!Refresh.isLikelyComponentType(exportValue)) {\n        areAllExportsComponents = false;\n      }\n    }\n    return hasExports && areAllExportsComponents;\n  };\n  var shouldInvalidateReactRefreshBoundary = (\n    Refresh,\n    prevExports,\n    nextExports\n  ) => {\n    const prevSignature = getRefreshBoundarySignature(Refresh, prevExports);\n    const nextSignature = getRefreshBoundarySignature(Refresh, nextExports);\n    if (prevSignature.length !== nextSignature.length) {\n      return true;\n    }\n    for (let i = 0; i < nextSignature.length; i++) {\n      if (prevSignature[i] !== nextSignature[i]) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // When this signature changes, it's unsafe to stop at this refresh boundary.\n  var getRefreshBoundarySignature = (Refresh, moduleExports) => {\n    const signature = [];\n    signature.push(Refresh.getFamilyByType(moduleExports));\n    if (moduleExports == null || typeof moduleExports !== \"object\") {\n      // Exit if we can't iterate over exports.\n      // (This is important for legacy environments.)\n      return signature;\n    }\n    for (const key in moduleExports) {\n      if (key === \"__esModule\") {\n        continue;\n      }\n      const desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n      if (desc && desc.get) {\n        continue;\n      }\n      const exportValue = moduleExports[key];\n      signature.push(key);\n      signature.push(Refresh.getFamilyByType(exportValue));\n    }\n    return signature;\n  };\n  var registerExportsForReactRefresh = (Refresh, moduleExports, moduleID) => {\n    Refresh.register(moduleExports, moduleID + \" %exports%\");\n    if (moduleExports == null || typeof moduleExports !== \"object\") {\n      // Exit if we can't iterate over exports.\n      // (This is important for legacy environments.)\n      return;\n    }\n    for (const key in moduleExports) {\n      const desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n      if (desc && desc.get) {\n        // Don't invoke getters as they may have side effects.\n        continue;\n      }\n      const exportValue = moduleExports[key];\n      const typeID = moduleID + \" %exports% \" + key;\n      Refresh.register(exportValue, typeID);\n    }\n  };\n  global.__accept = metroHotUpdateModule;\n}\nif (__DEV__) {\n  // The metro require polyfill can not have module dependencies.\n  // The Systrace and ReactRefresh dependencies are, therefore, made publicly\n  // available. Ideally, the dependency would be inversed in a way that\n  // Systrace / ReactRefresh could integrate into Metro rather than\n  // having to make them publicly available.\n\n  var requireSystrace = function requireSystrace() {\n    return (\n      // $FlowFixMe[prop-missing]\n      global[__METRO_GLOBAL_PREFIX__ + \"__SYSTRACE\"] || metroRequire.Systrace\n    );\n  };\n  var requireRefresh = function requireRefresh() {\n    return (\n      // $FlowFixMe[prop-missing]\n      global[__METRO_GLOBAL_PREFIX__ + \"__ReactRefresh\"] || metroRequire.Refresh\n    );\n  };\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @polyfill\n * @nolint\n * @format\n */\n\n/* eslint-disable no-shadow, eqeqeq, curly, no-unused-vars, no-void, no-control-regex  */\n\n/**\n * This pipes all of our console logging functions to native logging so that\n * JavaScript errors in required modules show up in Xcode via NSLog.\n */\nconst inspect = (function() {\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  //\n  // https://github.com/joyent/node/blob/master/lib/util.js\n\n  function inspect(obj, opts) {\n    var ctx = {\n      seen: [],\n      formatValueCalls: 0,\n      stylize: stylizeNoColor,\n    };\n    return formatValue(ctx, obj, opts.depth);\n  }\n\n  function stylizeNoColor(str, styleType) {\n    return str;\n  }\n\n  function arrayToHash(array) {\n    var hash = {};\n\n    array.forEach(function(val, idx) {\n      hash[val] = true;\n    });\n\n    return hash;\n  }\n\n  function formatValue(ctx, value, recurseTimes) {\n    ctx.formatValueCalls++;\n    if (ctx.formatValueCalls > 200) {\n      return `[TOO BIG formatValueCalls ${ctx.formatValueCalls} exceeded limit of 200]`;\n    }\n\n    // Primitive types cannot have properties\n    var primitive = formatPrimitive(ctx, value);\n    if (primitive) {\n      return primitive;\n    }\n\n    // Look up the keys of the object.\n    var keys = Object.keys(value);\n    var visibleKeys = arrayToHash(keys);\n\n    // IE doesn't make error fields non-enumerable\n    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n    if (\n      isError(value) &&\n      (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)\n    ) {\n      return formatError(value);\n    }\n\n    // Some type of object without properties can be shortcutted.\n    if (keys.length === 0) {\n      if (isFunction(value)) {\n        var name = value.name ? ': ' + value.name : '';\n        return ctx.stylize('[Function' + name + ']', 'special');\n      }\n      if (isRegExp(value)) {\n        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n      }\n      if (isDate(value)) {\n        return ctx.stylize(Date.prototype.toString.call(value), 'date');\n      }\n      if (isError(value)) {\n        return formatError(value);\n      }\n    }\n\n    var base = '',\n      array = false,\n      braces = ['{', '}'];\n\n    // Make Array say that they are Array\n    if (isArray(value)) {\n      array = true;\n      braces = ['[', ']'];\n    }\n\n    // Make functions say that they are functions\n    if (isFunction(value)) {\n      var n = value.name ? ': ' + value.name : '';\n      base = ' [Function' + n + ']';\n    }\n\n    // Make RegExps say that they are RegExps\n    if (isRegExp(value)) {\n      base = ' ' + RegExp.prototype.toString.call(value);\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + Date.prototype.toUTCString.call(value);\n    }\n\n    // Make error with message first say the error\n    if (isError(value)) {\n      base = ' ' + formatError(value);\n    }\n\n    if (keys.length === 0 && (!array || value.length == 0)) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n      } else {\n        return ctx.stylize('[Object]', 'special');\n      }\n    }\n\n    ctx.seen.push(value);\n\n    var output;\n    if (array) {\n      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n    } else {\n      output = keys.map(function(key) {\n        return formatProperty(\n          ctx,\n          value,\n          recurseTimes,\n          visibleKeys,\n          key,\n          array,\n        );\n      });\n    }\n\n    ctx.seen.pop();\n\n    return reduceToSingleString(output, base, braces);\n  }\n\n  function formatPrimitive(ctx, value) {\n    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');\n    if (isString(value)) {\n      var simple =\n        \"'\" +\n        JSON.stringify(value)\n          .replace(/^\"|\"$/g, '')\n          .replace(/'/g, \"\\\\'\")\n          .replace(/\\\\\"/g, '\"') +\n        \"'\";\n      return ctx.stylize(simple, 'string');\n    }\n    if (isNumber(value)) return ctx.stylize('' + value, 'number');\n    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');\n    // For some reason typeof null is \"object\", so special case here.\n    if (isNull(value)) return ctx.stylize('null', 'null');\n  }\n\n  function formatError(value) {\n    return '[' + Error.prototype.toString.call(value) + ']';\n  }\n\n  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n    var output = [];\n    for (var i = 0, l = value.length; i < l; ++i) {\n      if (hasOwnProperty(value, String(i))) {\n        output.push(\n          formatProperty(\n            ctx,\n            value,\n            recurseTimes,\n            visibleKeys,\n            String(i),\n            true,\n          ),\n        );\n      } else {\n        output.push('');\n      }\n    }\n    keys.forEach(function(key) {\n      if (!key.match(/^\\d+$/)) {\n        output.push(\n          formatProperty(ctx, value, recurseTimes, visibleKeys, key, true),\n        );\n      }\n    });\n    return output;\n  }\n\n  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n    var name, str, desc;\n    desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};\n    if (desc.get) {\n      if (desc.set) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (desc.set) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n    if (!hasOwnProperty(visibleKeys, key)) {\n      name = '[' + key + ']';\n    }\n    if (!str) {\n      if (ctx.seen.indexOf(desc.value) < 0) {\n        if (isNull(recurseTimes)) {\n          str = formatValue(ctx, desc.value, null);\n        } else {\n          str = formatValue(ctx, desc.value, recurseTimes - 1);\n        }\n        if (str.indexOf('\\n') > -1) {\n          if (array) {\n            str = str\n              .split('\\n')\n              .map(function(line) {\n                return '  ' + line;\n              })\n              .join('\\n')\n              .substr(2);\n          } else {\n            str =\n              '\\n' +\n              str\n                .split('\\n')\n                .map(function(line) {\n                  return '   ' + line;\n                })\n                .join('\\n');\n          }\n        }\n      } else {\n        str = ctx.stylize('[Circular]', 'special');\n      }\n    }\n    if (isUndefined(name)) {\n      if (array && key.match(/^\\d+$/)) {\n        return str;\n      }\n      name = JSON.stringify('' + key);\n      if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n        name = name.substr(1, name.length - 2);\n        name = ctx.stylize(name, 'name');\n      } else {\n        name = name\n          .replace(/'/g, \"\\\\'\")\n          .replace(/\\\\\"/g, '\"')\n          .replace(/(^\"|\"$)/g, \"'\");\n        name = ctx.stylize(name, 'string');\n      }\n    }\n\n    return name + ': ' + str;\n  }\n\n  function reduceToSingleString(output, base, braces) {\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n    }, 0);\n\n    if (length > 60) {\n      return (\n        braces[0] +\n        (base === '' ? '' : base + '\\n ') +\n        ' ' +\n        output.join(',\\n  ') +\n        ' ' +\n        braces[1]\n      );\n    }\n\n    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n  }\n\n  // NOTE: These type checking functions intentionally don't use `instanceof`\n  // because it is fragile and can be easily faked with `Object.create()`.\n  function isArray(ar) {\n    return Array.isArray(ar);\n  }\n\n  function isBoolean(arg) {\n    return typeof arg === 'boolean';\n  }\n\n  function isNull(arg) {\n    return arg === null;\n  }\n\n  function isNullOrUndefined(arg) {\n    return arg == null;\n  }\n\n  function isNumber(arg) {\n    return typeof arg === 'number';\n  }\n\n  function isString(arg) {\n    return typeof arg === 'string';\n  }\n\n  function isSymbol(arg) {\n    return typeof arg === 'symbol';\n  }\n\n  function isUndefined(arg) {\n    return arg === void 0;\n  }\n\n  function isRegExp(re) {\n    return isObject(re) && objectToString(re) === '[object RegExp]';\n  }\n\n  function isObject(arg) {\n    return typeof arg === 'object' && arg !== null;\n  }\n\n  function isDate(d) {\n    return isObject(d) && objectToString(d) === '[object Date]';\n  }\n\n  function isError(e) {\n    return (\n      isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error)\n    );\n  }\n\n  function isFunction(arg) {\n    return typeof arg === 'function';\n  }\n\n  function objectToString(o) {\n    return Object.prototype.toString.call(o);\n  }\n\n  function hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  return inspect;\n})();\n\nconst OBJECT_COLUMN_NAME = '(index)';\nconst LOG_LEVELS = {\n  trace: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\nconst INSPECTOR_LEVELS = [];\nINSPECTOR_LEVELS[LOG_LEVELS.trace] = 'debug';\nINSPECTOR_LEVELS[LOG_LEVELS.info] = 'log';\nINSPECTOR_LEVELS[LOG_LEVELS.warn] = 'warning';\nINSPECTOR_LEVELS[LOG_LEVELS.error] = 'error';\n\n// Strip the inner function in getNativeLogFunction(), if in dev also\n// strip method printing to originalConsole.\nconst INSPECTOR_FRAMES_TO_SKIP = __DEV__ ? 2 : 1;\n\nfunction getNativeLogFunction(level) {\n  return function() {\n    let str;\n    if (arguments.length === 1 && typeof arguments[0] === 'string') {\n      str = arguments[0];\n    } else {\n      str = Array.prototype.map\n        .call(arguments, function(arg) {\n          return inspect(arg, {depth: 10});\n        })\n        .join(', ');\n    }\n\n    // TRICKY\n    // If more than one argument is provided, the code above collapses them all\n    // into a single formatted string. This transform wraps string arguments in\n    // single quotes (e.g. \"foo\" -> \"'foo'\") which then breaks the \"Warning:\"\n    // check below. So it's important that we look at the first argument, rather\n    // than the formatted argument string.\n    const firstArg = arguments[0];\n\n    let logLevel = level;\n    if (\n      typeof firstArg === 'string' &&\n      firstArg.slice(0, 9) === 'Warning: ' &&\n      logLevel >= LOG_LEVELS.error\n    ) {\n      // React warnings use console.error so that a stack trace is shown,\n      // but we don't (currently) want these to show a redbox\n      // (Note: Logic duplicated in ExceptionsManager.js.)\n      logLevel = LOG_LEVELS.warn;\n    }\n    if (global.__inspectorLog) {\n      global.__inspectorLog(\n        INSPECTOR_LEVELS[logLevel],\n        str,\n        [].slice.call(arguments),\n        INSPECTOR_FRAMES_TO_SKIP,\n      );\n    }\n    if (groupStack.length) {\n      str = groupFormat('', str);\n    }\n    global.nativeLoggingHook(str, logLevel);\n  };\n}\n\nfunction repeat(element, n) {\n  return Array.apply(null, Array(n)).map(function() {\n    return element;\n  });\n}\n\nfunction consoleTablePolyfill(rows) {\n  // convert object -> array\n  if (!Array.isArray(rows)) {\n    var data = rows;\n    rows = [];\n    for (var key in data) {\n      if (data.hasOwnProperty(key)) {\n        var row = data[key];\n        row[OBJECT_COLUMN_NAME] = key;\n        rows.push(row);\n      }\n    }\n  }\n  if (rows.length === 0) {\n    global.nativeLoggingHook('', LOG_LEVELS.info);\n    return;\n  }\n\n  var columns = Object.keys(rows[0]).sort();\n  var stringRows = [];\n  var columnWidths = [];\n\n  // Convert each cell to a string. Also\n  // figure out max cell width for each column\n  columns.forEach(function(k, i) {\n    columnWidths[i] = k.length;\n    for (var j = 0; j < rows.length; j++) {\n      var cellStr = (rows[j][k] || '?').toString();\n      stringRows[j] = stringRows[j] || [];\n      stringRows[j][i] = cellStr;\n      columnWidths[i] = Math.max(columnWidths[i], cellStr.length);\n    }\n  });\n\n  // Join all elements in the row into a single string with | separators\n  // (appends extra spaces to each cell to make separators  | aligned)\n  function joinRow(row, space) {\n    var cells = row.map(function(cell, i) {\n      var extraSpaces = repeat(' ', columnWidths[i] - cell.length).join('');\n      return cell + extraSpaces;\n    });\n    space = space || ' ';\n    return cells.join(space + '|' + space);\n  }\n\n  var separators = columnWidths.map(function(columnWidth) {\n    return repeat('-', columnWidth).join('');\n  });\n  var separatorRow = joinRow(separators, '-');\n  var header = joinRow(columns);\n  var table = [header, separatorRow];\n\n  for (var i = 0; i < rows.length; i++) {\n    table.push(joinRow(stringRows[i]));\n  }\n\n  // Notice extra empty line at the beginning.\n  // Native logging hook adds \"RCTLog >\" at the front of every\n  // logged string, which would shift the header and screw up\n  // the table\n  global.nativeLoggingHook('\\n' + table.join('\\n'), LOG_LEVELS.info);\n}\n\nconst GROUP_PAD = '\\u2502'; // Box light vertical\nconst GROUP_OPEN = '\\u2510'; // Box light down+left\nconst GROUP_CLOSE = '\\u2518'; // Box light up+left\n\nconst groupStack = [];\n\nfunction groupFormat(prefix, msg) {\n  // Insert group formatting before the console message\n  return groupStack.join('') + prefix + ' ' + (msg || '');\n}\n\nfunction consoleGroupPolyfill(label) {\n  global.nativeLoggingHook(groupFormat(GROUP_OPEN, label), LOG_LEVELS.info);\n  groupStack.push(GROUP_PAD);\n}\n\nfunction consoleGroupCollapsedPolyfill(label) {\n  global.nativeLoggingHook(groupFormat(GROUP_CLOSE, label), LOG_LEVELS.info);\n  groupStack.push(GROUP_PAD);\n}\n\nfunction consoleGroupEndPolyfill() {\n  groupStack.pop();\n  global.nativeLoggingHook(groupFormat(GROUP_CLOSE), LOG_LEVELS.info);\n}\n\nfunction consoleAssertPolyfill(expression, label) {\n  if (!expression) {\n    global.nativeLoggingHook('Assertion failed: ' + label, LOG_LEVELS.error);\n  }\n}\n\nif (global.nativeLoggingHook) {\n  const originalConsole = global.console;\n  // Preserve the original `console` as `originalConsole`\n  if (__DEV__ && originalConsole) {\n    const descriptor = Object.getOwnPropertyDescriptor(global, 'console');\n    if (descriptor) {\n      Object.defineProperty(global, 'originalConsole', descriptor);\n    }\n  }\n\n  global.console = {\n    error: getNativeLogFunction(LOG_LEVELS.error),\n    info: getNativeLogFunction(LOG_LEVELS.info),\n    log: getNativeLogFunction(LOG_LEVELS.info),\n    warn: getNativeLogFunction(LOG_LEVELS.warn),\n    trace: getNativeLogFunction(LOG_LEVELS.trace),\n    debug: getNativeLogFunction(LOG_LEVELS.trace),\n    table: consoleTablePolyfill,\n    group: consoleGroupPolyfill,\n    groupEnd: consoleGroupEndPolyfill,\n    groupCollapsed: consoleGroupCollapsedPolyfill,\n    assert: consoleAssertPolyfill,\n  };\n\n  Object.defineProperty(console, '_isPolyfilled', {\n    value: true,\n    enumerable: false,\n  });\n\n  // If available, also call the original `console` method since that is\n  // sometimes useful. Ex: on OS X, this will let you see rich output in\n  // the Safari Web Inspector console.\n  if (__DEV__ && originalConsole) {\n    Object.keys(console).forEach(methodName => {\n      const reactNativeMethod = console[methodName];\n      if (originalConsole[methodName]) {\n        console[methodName] = function() {\n          originalConsole[methodName](...arguments);\n          reactNativeMethod.apply(console, arguments);\n        };\n      }\n    });\n\n    // The following methods are not supported by this polyfill but\n    // we still should pass them to original console if they are\n    // supported by it.\n    ['clear', 'dir', 'dirxml', 'profile', 'profileEnd'].forEach(methodName => {\n      if (typeof originalConsole[methodName] === 'function') {\n        console[methodName] = function() {\n          originalConsole[methodName](...arguments);\n        };\n      }\n    });\n  }\n} else if (!global.console) {\n  function stub() {}\n  const log = global.print || stub;\n\n  global.console = {\n    debug: log,\n    error: log,\n    info: log,\n    log: log,\n    trace: log,\n    warn: log,\n    assert(expression, label) {\n      if (!expression) {\n        log('Assertion failed: ' + label);\n      }\n    },\n    clear: stub,\n    dir: stub,\n    dirxml: stub,\n    group: stub,\n    groupCollapsed: stub,\n    groupEnd: stub,\n    profile: stub,\n    profileEnd: stub,\n    table: stub,\n  };\n\n  Object.defineProperty(console, '_isPolyfilled', {\n    value: true,\n    enumerable: false,\n  });\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict\n * @polyfill\n */\n\nlet _inGuard = 0;\n\ntype ErrorHandler = (error: mixed, isFatal: boolean) => void;\ntype Fn<Args, Return> = (...Args) => Return;\n\n/**\n * This is the error handler that is called when we encounter an exception\n * when loading a module. This will report any errors encountered before\n * ExceptionsManager is configured.\n */\nlet _globalHandler: ErrorHandler = function onError(\n  e: mixed,\n  isFatal: boolean,\n) {\n  throw e;\n};\n\n/**\n * The particular require runtime that we are using looks for a global\n * `ErrorUtils` object and if it exists, then it requires modules with the\n * error handler specified via ErrorUtils.setGlobalHandler by calling the\n * require function with applyWithGuard. Since the require module is loaded\n * before any of the modules, this ErrorUtils must be defined (and the handler\n * set) globally before requiring anything.\n */\nconst ErrorUtils = {\n  setGlobalHandler(fun: ErrorHandler): void {\n    _globalHandler = fun;\n  },\n  getGlobalHandler(): ErrorHandler {\n    return _globalHandler;\n  },\n  reportError(error: mixed): void {\n    _globalHandler && _globalHandler(error, false);\n  },\n  reportFatalError(error: mixed): void {\n    // NOTE: This has an untyped call site in Metro.\n    _globalHandler && _globalHandler(error, true);\n  },\n  applyWithGuard<TArgs: $ReadOnlyArray<mixed>, TOut>(\n    fun: Fn<TArgs, TOut>,\n    context?: ?mixed,\n    args?: ?TArgs,\n    // Unused, but some code synced from www sets it to null.\n    unused_onError?: null,\n    // Some callers pass a name here, which we ignore.\n    unused_name?: ?string,\n  ): ?TOut {\n    try {\n      _inGuard++;\n      /* $FlowFixMe[incompatible-call] : TODO T48204745 (1) apply(context,\n       * null) is fine. (2) array -> rest array should work */\n      /* $FlowFixMe[incompatible-type] : TODO T48204745 (1) apply(context,\n       * null) is fine. (2) array -> rest array should work */\n      return fun.apply(context, args);\n    } catch (e) {\n      ErrorUtils.reportError(e);\n    } finally {\n      _inGuard--;\n    }\n    return null;\n  },\n  applyWithGuardIfNeeded<TArgs: $ReadOnlyArray<mixed>, TOut>(\n    fun: Fn<TArgs, TOut>,\n    context?: ?mixed,\n    args?: ?TArgs,\n  ): ?TOut {\n    if (ErrorUtils.inGuard()) {\n      /* $FlowFixMe[incompatible-call] : TODO T48204745 (1) apply(context,\n       * null) is fine. (2) array -> rest array should work */\n      /* $FlowFixMe[incompatible-type] : TODO T48204745 (1) apply(context,\n       * null) is fine. (2) array -> rest array should work */\n      return fun.apply(context, args);\n    } else {\n      ErrorUtils.applyWithGuard(fun, context, args);\n    }\n    return null;\n  },\n  inGuard(): boolean {\n    return !!_inGuard;\n  },\n  guard<TArgs: $ReadOnlyArray<mixed>, TOut>(\n    fun: Fn<TArgs, TOut>,\n    name?: ?string,\n    context?: ?mixed,\n  ): ?(...TArgs) => ?TOut {\n    // TODO: (moti) T48204753 Make sure this warning is never hit and remove it - types\n    // should be sufficient.\n    if (typeof fun !== 'function') {\n      console.warn('A function must be passed to ErrorUtils.guard, got ', fun);\n      return null;\n    }\n    const guardName = name ?? fun.name ?? '<generated guard>';\n    function guarded(...args: TArgs): ?TOut {\n      return ErrorUtils.applyWithGuard(\n        fun,\n        context ?? this,\n        args,\n        null,\n        guardName,\n      );\n    }\n\n    return guarded;\n  },\n};\n\nglobal.ErrorUtils = ErrorUtils;\n\nexport type ErrorUtilsT = typeof ErrorUtils;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @polyfill\n * @nolint\n */\n\n(function() {\n  'use strict';\n\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  /**\n   * Returns an array of the given object's own enumerable entries.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\n   */\n  if (typeof Object.entries !== 'function') {\n    Object.entries = function(object) {\n      // `null` and `undefined` values are not allowed.\n      if (object == null) {\n        throw new TypeError('Object.entries called on non-object');\n      }\n\n      const entries = [];\n      for (const key in object) {\n        if (hasOwnProperty.call(object, key)) {\n          entries.push([key, object[key]]);\n        }\n      }\n      return entries;\n    };\n  }\n\n  /**\n   * Returns an array of the given object's own enumerable entries.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\n   */\n  if (typeof Object.values !== 'function') {\n    Object.values = function(object) {\n      // `null` and `undefined` values are not allowed.\n      if (object == null) {\n        throw new TypeError('Object.values called on non-object');\n      }\n\n      const values = [];\n      for (const key in object) {\n        if (hasOwnProperty.call(object, key)) {\n          values.push(object[key]);\n        }\n      }\n      return values;\n    };\n  }\n})();\n","import '@tarojs/rn-supporter/entry-file.js'",""],"x_facebook_sources":[null,[{"names":["<global>","global.$RefreshReg$","global.$RefreshSig$","<anonymous>","clear","define","metroRequire","initializingModuleIds.slice.map$argument_0","shouldPrintRequireCycle","isIgnored","regExps.some$argument_0","modules.every$argument_0","metroImportDefault","metroImportAll","fallbackRequireContext","guardedLoadModule","unpackModuleId","packModuleId","registerSegment","moduleIds.forEach$argument_0","loadModuleImplementation","unknownModuleError","metroRequire.Systrace.beginEvent","metroRequire.Systrace.endEvent","metroRequire.getModules","createHotReloadingObject","hot.accept","hot.dispose","metroHotUpdateModule","topologicalSort$argument_1","topologicalSort$argument_2","setTimeout$argument_0","topologicalSort","traverseDependentNodes","dependentNodes.forEach$argument_0","roots.forEach$argument_0","runUpdatedModule","performFullRefresh","isReactRefreshBoundary","shouldInvalidateReactRefreshBoundary","getRefreshBoundarySignature","registerExportsForReactRefresh","requireSystrace","requireRefresh"],"mappings":"AAA;wBC8B,QD;wBEC,MC,cH;AIE;CJO;AKK;CL2C;AMC;aCuB,6DD;CNe;AQI;oBCM;mCCC,+BD,CD;uBGG,8BH;CRC;AYC;CZoB;AaE;CbkC;uBcM;CdS;AeE;Cfe;AgBG;ChBO;AiBE;CjBE;AkBI;sBCgB;KDI;ClBE;AoBC;8BnBoD;SmBE;CpBmD;AqBC;CrBQ;gBsBI,QtB;cuBC,QvB;4BwBG;GxBE;iCyBG;cCK;ODG;eEC;OFE;GzBG;+B4BE;QC+C;SD6C;QEC,gBF;yCG0G;SHI;G5BG;0BgCC;ICI;6BCc;ODE;KDG;kBGC;KHE;GhCE;2BoCC;GpC8D;6BqCC;GrCwC;+BsCG;GtC0B;6CuCC;GvCgB;oCwCG;GxCqB;uCyCC;GzCiB;wB0CU;G1CK;uB2CC;G3CK"}],[{"names":["<global>","<anonymous>","inspect","stylizeNoColor","arrayToHash","array.forEach$argument_0","formatValue","keys.map$argument_0","formatPrimitive","formatError","formatArray","keys.forEach$argument_0","formatProperty","str.split.map$argument_0","reduceToSingleString","output.reduce$argument_0","isArray","isBoolean","isNull","isNullOrUndefined","isNumber","isString","isSymbol","isUndefined","isRegExp","isObject","isDate","isError","isFunction","objectToString","hasOwnProperty","getNativeLogFunction","Array.prototype.map.call$argument_1","repeat","Array.apply.map$argument_0","consoleTablePolyfill","columns.forEach$argument_0","joinRow","row.map$argument_0","columnWidths.map$argument_0","groupFormat","consoleGroupPolyfill","consoleGroupCollapsedPolyfill","consoleGroupEndPolyfill","consoleAssertPolyfill","Object.keys.forEach$argument_0","methodName","forEach$argument_0","stub","global.console.assert"],"mappings":"AAA;iBCiB;ECwB;GDO;EEE;GFE;EGE;kBCG;KDE;GHG;EKE;wBC2F;ODS;GLM;EOE;GPgB;EQE;GRE;ESE;iBCkB;KDM;GTE;EWE;mBC4B;eDE;qBCQ;iBDE;GX0B;EaE;+BCE;KDI;Gbc;EeI;GfE;EgBE;GhBE;EiBE;GjBE;EkBE;GlBE;EmBE;GnBE;EoBE;GpBE;EqBE;GrBE;EsBE;GtBE;EuBE;GvBE;EwBE;GxBE;EyBE;GzBE;E0BE;G1BK;E2BE;G3BE;E4BE;G5BE;E6BE;G7BE;CDG;A+BmB;S9BC;yB+BM;S/BE;G8BmC;C/BC;AiCE;yCCC;GDE;CjCC;AmCE;kBCwB;GDQ;EEI;wBCC;KDG;GFG;oCIE;GJE;CnCc;AwCQ;CxCG;AyCE;CzCG;A0CE;C1CG;A2CE;C3CG;A4CE;C5CI;iC6CmC;8BCG;SDG;K7CE;gE+CK;8BDE;SCE;K/CE;EgDG,kBhD;IiDU;KjDI"}],[{"names":["<global>","onError","ErrorUtils.setGlobalHandler","ErrorUtils.getGlobalHandler","ErrorUtils.reportError","ErrorUtils.reportFatalError","ErrorUtils.applyWithGuard","ErrorUtils.applyWithGuardIfNeeded","ErrorUtils.inGuard","ErrorUtils.guard","guarded"],"mappings":"AAA;mCCqB;CDK;EEW;GFE;EGC;GHE;EIC;GJE;EKC;GLG;EMC;GNsB;EOC;GPe;EQC;GRE;ESC;ICY;KDQ;GTG"}],[{"names":["<global>","<anonymous>","entries","values"],"mappings":"AAA;CCW;qBCU;KDa;oBEQ;KFa;CDE"}],[{"names":["<global>"],"mappings":"AAA"}],[{"names":[],"mappings":""}]],"names":["global","__r","metroRequire","__METRO_GLOBAL_PREFIX__","factory","moduleId","dependencyMap","modules","mod","hasError","importedAll","EMPTY","importedDefault","isInitialized","publicModule","exports","__c","clear","__registerSegment","segmentId","moduleDefiner","moduleIds","moduleDefinersBySegmentID","forEach","definingSegmentByModuleID","has","set","hasOwnProperty","Object","create","moduleIdReallyIsNumber","module","guardedLoadModule","metroImportDefault","__esModule","default","metroImportAll","key","call","importDefault","importAll","context","Error","inGuard","ErrorUtils","returnValue","loadModuleImplementation","e","reportFatalError","ID_MASK_SHIFT","LOCAL_ID_MASK","unpackModuleId","localId","packModuleId","value","Map","length","_definingSegmentByMod","get","undefined","definer","delete","nativeRequire","_unpackModuleId","error","_module","moduleObject","id","globalThis","window","this","inspect","stylizeNoColor","str","arrayToHash","array","hash","val","formatValue","ctx","recurseTimes","formatValueCalls","primitive","formatPrimitive","keys","visibleKeys","isError","indexOf","formatError","isFunction","name","stylize","isRegExp","RegExp","prototype","toString","isDate","Date","ar","output","base","braces","Array","isArray","toUTCString","seen","push","formatArray","map","formatProperty","pop","reduceToSingleString","isUndefined","simple","JSON","stringify","replace","isNumber","isBoolean","isNull","i","l","String","match","desc","getOwnPropertyDescriptor","split","line","join","substr","reduce","prev","cur","numLinesEst","arg","re","isObject","objectToString","d","o","obj","prop","opts","depth","OBJECT_COLUMN_NAME","LOG_LEVELS","trace","info","warn","INSPECTOR_LEVELS","INSPECTOR_FRAMES_TO_SKIP","getNativeLogFunction","level","arguments","firstArg","logLevel","slice","__inspectorLog","groupStack","groupFormat","nativeLoggingHook","repeat","element","n","apply","GROUP_PAD","GROUP_OPEN","GROUP_CLOSE","prefix","msg","console","log","debug","table","rows","data","row","columns","sort","stringRows","columnWidths","k","j","cellStr","Math","max","separatorRow","joinRow","columnWidth","space","cells","cell","group","label","groupEnd","groupCollapsed","assert","expression","defineProperty","enumerable","stub","print","dir","dirxml","profile","profileEnd","_inGuard","_globalHandler","setGlobalHandler","fun","getGlobalHandler","reportError","applyWithGuard","args","applyWithGuardIfNeeded","guard","_ref","guardName","_len","_key","entries","object","TypeError","values","r"],"mappings":"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"}